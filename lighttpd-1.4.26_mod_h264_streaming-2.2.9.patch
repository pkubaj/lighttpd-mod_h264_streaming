diff -Naur ../lighttpd-1.4.26.orig/COPYING_H264 ./COPYING_H264
--- ../lighttpd-1.4.26.orig/COPYING_H264	1970-01-01 01:00:00.000000000 +0100
+++ ./COPYING_H264	2010-06-03 15:36:00.855287990 +0200
@@ -0,0 +1,11 @@
+*************************************************************************
+* mod_h264_streaming is licensed for non-commercial use only under the	*
+* Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported	*	 
+* license.								*
+*									*
+* License URL:								*
+* http://creativecommons.org/licenses/by-nc-sa/3.0/			*
+*									*
+* For commercial use, please check licence terms at:			*
+* http://h264.code-shop.com/trac#License                  		*
+*************************************************************************
diff -Naur ../lighttpd-1.4.26.orig/configure.ac ./configure.ac
--- ../lighttpd-1.4.26.orig/configure.ac	2010-06-03 15:35:40.444162823 +0200
+++ ./configure.ac	2010-06-03 15:36:00.856292023 +0200
--- configure.ac.orig	2017-11-14 20:17:06.307829000 +0100
+++ configure.ac	2017-11-14 20:19:54.680667000 +0100
@@ -1341,6 +1341,7 @@
   mod_vhostdb \
   mod_webdav \
   mod_wstunnel \
+  mod_h264_streaming \
 "
 
 lighty_track_feature() {
diff -Naur ../lighttpd-1.4.26.orig/src/Makefile.am ./src/Makefile.am
--- ../lighttpd-1.4.26.orig/src/Makefile.am	2010-06-03 15:35:40.440146694 +0200
+++ ./src/Makefile.am	2010-06-03 15:36:00.856292023 +0200
@@ -100,6 +100,15 @@
 mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
 mod_flv_streaming_la_LIBADD = $(common_libadd)
 
+lib_LTLIBRARIES += mod_h264_streaming.la
+mod_h264_streaming_la_SOURCES = mod_h264_streaming.c mod_streaming_export.h \
+	moov.c moov.h mp4_io.c mp4_io.h mp4_reader.c mp4_reader.h mp4_writer.c \
+	mp4_writer.h mp4_process.c mp4_process.h output_bucket.c output_bucket.h \
+	output_mp4.c output_mp4.h
+mod_h264_streaming_la_CFLAGS = $(AM_CFLAGS) -DBUILDING_H264_STREAMING
+mod_h264_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_h264_streaming_la_LIBADD = $(common_libadd)
+
 lib_LTLIBRARIES += mod_evasive.la
 mod_evasive_la_SOURCES = mod_evasive.c
 mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
diff -Naur ../lighttpd-1.4.26.orig/src/mod_h264_streaming.c ./src/mod_h264_streaming.c
--- ../lighttpd-1.4.26.orig/src/mod_h264_streaming.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mod_h264_streaming.c	2010-06-03 15:36:00.858299808 +0200
@@ -0,0 +1,459 @@
+/*******************************************************************************
+ mod_h264_streaming.c
+
+ mod_h264_streaming - A lighttpd plugin for pseudo-streaming Quicktime/MPEG4 files.
+
+ Copyright (C) 2007-2009 CodeShop B.V
+
+ Licensing
+ The Streaming Module is licened under a Creative Commons License. It
+ allows you to use, modify and redistribute the module, but only for
+ *noncommercial* purposes. For corporate use, please apply for a
+ commercial license.
+
+ Creative Commons License:
+ http://creativecommons.org/licenses/by-nc-sa/3.0/
+
+ Commercial License for H264 Streaming Module:
+ http://h264.code-shop.com/trac/wiki/Mod-H264-Streaming-License-Version2
+
+ Commercial License for Smooth Streaming Module:
+ http://smoothstreaming.code-shop.com/trac/wiki/Mod-Smooth-Streaming-License
+******************************************************************************/ 
+
+// Example configuration 
+
+/*
+# Add the module to your server list in lighttpd.conf
+server.modules = (
+  "mod_expire",
+  "mod_secdownload",
+  "mod_h264_streaming",
+  etc...
+}
+
+# Files ending in .mp4 and .f4v are served by the module 
+h264-streaming.extensions = ( ".mp4", ".f4v" )
+# The number of seconds after which the bandwidth is shaped (defaults to 0=disable)
+h264-streaming.buffer-seconds = 10
+
+# Add Expires/Cache-Control header
+$HTTP["url"] =~ "\.(mp4|f4v)$" {
+  expire.url = ( "" => "access 8 hours" )
+}
+
+*/
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "base.h"
+#include "log.h"
+#include "buffer.h"
+#include "response.h"
+#include "http_chunk.h"
+#include "stat_cache.h"
+#include "etag.h"
+
+#include "plugin.h"
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "mp4_io.h"
+#include "mp4_process.h"
+#include "moov.h"
+#include "output_bucket.h"
+#ifdef BUILDING_H264_STREAMING
+#include "output_mp4.h"
+#define X_MOD_STREAMING_KEY X_MOD_H264_STREAMING_KEY
+#define X_MOD_STREAMING_VERSION X_MOD_H264_STREAMING_VERSION
+#define H264_STREAMING_HANDLER "h264-streaming.extensions"
+#endif
+#ifdef BUILDING_SMOOTH_STREAMING
+#include "ism_reader.h"
+#include "output_ismv.h"
+#define X_MOD_STREAMING_KEY X_MOD_SMOOTH_STREAMING_KEY
+#define X_MOD_STREAMING_VERSION X_MOD_SMOOTH_STREAMING_VERSION
+#define H264_STREAMING_HANDLER "smooth-streaming.extensions"
+#endif
+#ifdef BUILDING_FLV_STREAMING
+#define H264_STREAMING_HANDLER "flv-streaming.extensions"
+#include "output_flv.h"
+#endif
+
+/* plugin config for all request/connections */
+
+typedef struct {
+  array *extensions;
+  unsigned short buffer_seconds;
+} plugin_config;
+
+typedef struct {
+  PLUGIN_DATA;
+
+  plugin_config **config_storage;
+
+  plugin_config conf;
+} plugin_data;
+
+typedef struct {
+  struct mp4_split_options_t* options;
+  int play_position; /* (in seconds) */
+  unsigned short buffer_seconds;
+} handler_ctx;
+
+static handler_ctx * handler_ctx_init(unsigned short buffer_seconds) {
+  handler_ctx * hctx;
+
+  hctx = calloc(1, sizeof(*hctx));
+
+  hctx->options = mp4_split_options_init();
+  hctx->play_position = 0;
+  hctx->buffer_seconds = buffer_seconds;
+
+  return hctx;
+}
+
+static void handler_ctx_free(handler_ctx *hctx) {
+  mp4_split_options_exit(hctx->options);
+  free(hctx);
+}
+
+/* init the plugin data */
+INIT_FUNC(mod_h264_streaming_init) {
+  plugin_data *p;
+
+  p = calloc(1, sizeof(*p));
+
+  return p;
+}
+
+/* detroy the plugin data */
+FREE_FUNC(mod_h264_streaming_free) {
+  plugin_data *p = p_d;
+
+  UNUSED(srv);
+
+  if (!p) return HANDLER_GO_ON;
+
+  if (p->config_storage) {
+    size_t i;
+
+    for (i = 0; i < srv->config_context->used; i++) {
+      plugin_config *s = p->config_storage[i];
+
+      if (!s) continue;
+
+      array_free(s->extensions);
+
+      free(s);
+    }
+    free(p->config_storage);
+  }
+
+  free(p);
+
+  return HANDLER_GO_ON;
+}
+
+/* handle plugin config and check values */
+
+#define CONFIG_H264STREAMING_EXTENSIONS     "h264-streaming.extensions"
+#define CONFIG_H264STREAMING_BUFFER_SECONDS "h264-streaming.buffer-seconds"
+
+SETDEFAULTS_FUNC(mod_h264_streaming_set_defaults) {
+  plugin_data *p = p_d;
+  size_t i = 0;
+
+  config_values_t cv[] = {
+    { CONFIG_H264STREAMING_EXTENSIONS,     NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION }, /* 0 */
+    { CONFIG_H264STREAMING_BUFFER_SECONDS, NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION }, /* 1 */
+    { NULL,                                NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
+  };
+
+  if (!p) return HANDLER_ERROR;
+
+  p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+
+  for (i = 0; i < srv->config_context->used; i++) {
+    data_config const* config = (data_config const*)srv->config_context->data[i];
+    plugin_config *s;
+
+    s = calloc(1, sizeof(plugin_config));
+    s->extensions     = array_init();
+    s->buffer_seconds = 0;
+
+    cv[0].destination = s->extensions;
+    cv[1].destination = &(s->buffer_seconds);
+
+    p->config_storage[i] = s;
+
+    if (0 != config_insert_values_global(srv, config->value, cv, i == 0 ? T_CONFIG_SCOPE_SERVER : T_CONFIG_SCOPE_CONNECTION)) {
+      return HANDLER_ERROR;
+    }
+  }
+
+  return HANDLER_GO_ON;
+}
+
+#define PATCH_OPTION(x) \
+  p->conf.x = s->x;
+static int mod_h264_streaming_patch_connection(server *srv, connection *con, plugin_data *p) {
+  size_t i, j;
+  plugin_config *s = p->config_storage[0];
+
+  PATCH_OPTION(extensions);
+  PATCH_OPTION(buffer_seconds);
+
+  /* skip the first, the global context */
+  for (i = 1; i < srv->config_context->used; i++) {
+    data_config *dc = (data_config *)srv->config_context->data[i];
+    s = p->config_storage[i];
+
+    /* condition didn't match */
+    if (!config_check_cond(srv, con, dc)) continue;
+
+    /* merge config */
+    for (j = 0; j < dc->value->used; j++) {
+      data_unset *du = dc->value->data[j];
+
+      if (buffer_is_equal_string(du->key, CONST_STR_LEN(CONFIG_H264STREAMING_EXTENSIONS))) {
+        PATCH_OPTION(extensions);
+      } else
+      if (buffer_is_equal_string(du->key, CONST_STR_LEN(CONFIG_H264STREAMING_BUFFER_SECONDS))) {
+        PATCH_OPTION(buffer_seconds);
+      }
+    }
+  }
+
+  return 0;
+}
+#undef PATCH_OPTION
+
+URIHANDLER_FUNC(mod_h264_streaming_path_handler) {
+  plugin_data *p = p_d;
+  size_t s_len;
+  size_t k;
+  handler_ctx *hctx;
+
+  UNUSED(srv);
+
+  s_len = buffer_string_length(con->physical.path);
+  if (0 == s_len) return HANDLER_GO_ON;
+
+  mod_h264_streaming_patch_connection(srv, con, p);
+
+  if (con->plugin_ctx[p->id]) {
+    hctx = con->plugin_ctx[p->id];
+  } else {
+    hctx = handler_ctx_init(p->conf.buffer_seconds);
+    con->plugin_ctx[p->id] = hctx;
+  }
+
+
+  for (k = 0; k < p->conf.extensions->used; k++) {
+    data_string *ds = (data_string *)p->conf.extensions->data[k];
+    size_t ct_len = buffer_string_length(ds->value);
+
+    if (ct_len > s_len) continue;
+    if (ct_len == 0) continue;
+
+    if (0 == strncmp(con->physical.path->ptr + s_len - ct_len, ds->value->ptr, ct_len)) {
+      buffer *mtime;
+      stat_cache_entry *sce = NULL;
+
+      // Range requests are currently not supported, so let mod_staticfile
+      // handle it. Obviously the 'start' parameter doesn't work with
+      // mod_staticfile and so the movie always plays from the beginning,
+      // but at least it makes streaming and seeking in VLC work.
+      if (con->conf.range_requests &&
+         NULL != array_get_element(con->request.headers, "Range")) {
+          return HANDLER_GO_ON;
+      }
+
+      response_header_overwrite(srv, con,
+        CONST_STR_LEN(X_MOD_STREAMING_KEY),
+        CONST_STR_LEN(X_MOD_STREAMING_VERSION));
+
+      if(con->uri.query->ptr && !mp4_split_options_set(hctx->options, con->uri.query->ptr, con->uri.query->used))
+      {
+        con->http_status = 403;
+       	return HANDLER_FINISHED;
+      }
+
+      /* get file info */
+      if (HANDLER_GO_ON != stat_cache_get_entry(srv, con, con->physical.path, &sce))
+      {
+        con->http_status = 403;
+       	return HANDLER_FINISHED;
+      }
+
+      /* we are safe now, let's build a h264 header */
+      uint64_t content_length = 0;
+      {
+        unsigned int filesize = sce->st.st_size;
+
+        struct bucket_t* buckets = 0;
+        int verbose = 0;
+        int http_status =
+          mp4_process(con->physical.path->ptr, filesize, verbose, &buckets, hctx->options);
+
+        if(http_status != 200)
+        {
+          if(buckets)
+          {
+            buckets_exit(buckets);
+          }
+
+          return http_status;
+        }
+
+        response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"),
+                                  CONST_STR_LEN("video/mp4"));
+
+        {
+          struct bucket_t* bucket = buckets;
+          if(bucket)
+          {
+            do
+            {
+              switch(bucket->type_)
+              {
+              case BUCKET_TYPE_MEMORY:
+              {
+               http_chunk_append_mem(srv, con, bucket->buf_, bucket->size_);
+                
+             
+              }
+                break;
+              case BUCKET_TYPE_FILE:
+              http_chunk_append_file_range(srv, con, con->physical.path, bucket->offset_, bucket->size_) ;
+              break;
+              }
+              content_length += bucket->size_;
+              bucket = bucket->next_;
+            } while(bucket != buckets);
+            buckets_exit(buckets);
+          }
+        }
+      }
+
+      // ETag header
+      {
+        buffer *etag = buffer_init_buffer(sce->etag);
+        buffer_append_int(etag, content_length);
+        etag_mutate(con->physical.etag, etag);
+        response_header_overwrite(srv, con, CONST_STR_LEN("ETag"),
+                                  CONST_BUF_LEN(con->physical.etag));
+        buffer_free(etag);
+      }
+
+      // Last-Modified header
+      mtime = strftime_cache_get(srv, sce->st.st_mtime);
+      response_header_overwrite(srv, con, CONST_STR_LEN("Last-Modified"),
+                                CONST_BUF_LEN(mtime));
+
+      if (HANDLER_FINISHED == http_response_handle_cachable(srv, con, mtime))
+      {
+        return HANDLER_FINISHED;
+      }
+
+      con->file_finished = 1;
+
+      if(hctx->buffer_seconds && hctx->buffer_seconds < hctx->options->seconds)
+      {
+        off_t moov_offset = hctx->options->byte_offsets[hctx->buffer_seconds];
+        con->conf.kbytes_per_second = moov_offset / 1024;
+      }
+
+      return HANDLER_FINISHED;
+    }
+  }
+
+  /* not found */
+  return HANDLER_GO_ON;
+}
+
+TRIGGER_FUNC(mod_h264_streaming_trigger) {
+  plugin_data *p = p_d;
+  size_t i;
+
+  /* check all connections */
+  for (i = 0; i < srv->conns->used; i++) {
+    connection *con = srv->conns->ptr[i];
+    handler_ctx *hctx = con->plugin_ctx[p->id];
+    int t_diff = srv->cur_ts - con->connection_start;
+
+    if(hctx == NULL)
+      continue;
+
+    // check if bandwidth shaping is enabled
+    if(!hctx->buffer_seconds)
+    {
+      continue;
+    }
+
+    hctx->play_position = srv->cur_ts - con->connection_start;
+
+    // when we are near the end you're no longer throttled
+    if((t_diff + hctx->buffer_seconds) >= hctx->options->seconds)
+    {
+      con->conf.kbytes_per_second = 0;
+      continue;
+    }
+
+    off_t moov_offset = hctx->options->byte_offsets[t_diff + hctx->buffer_seconds];
+
+    if(con->bytes_written < moov_offset)
+    {
+      con->conf.kbytes_per_second = 1 + (moov_offset - con->bytes_written) / 1024;
+    }
+    else
+    {
+      // throttle connection to a low speed (set to the size of the TCP send buffer) as the buffer is full
+      con->conf.kbytes_per_second = 32;
+    }
+  }
+
+  return HANDLER_GO_ON;
+}
+
+handler_t mod_h264_streaming_cleanup(server *srv, connection *con, void *p_d) {
+  plugin_data *p = p_d;
+  handler_ctx *hctx = con->plugin_ctx[p->id];
+
+  UNUSED(srv);
+
+  if(hctx == NULL)
+    return HANDLER_GO_ON;
+
+  handler_ctx_free(hctx);
+  con->plugin_ctx[p->id] = NULL;
+
+  return HANDLER_GO_ON;
+}
+
+/* this function is called at dlopen() time and inits the callbacks */
+
+int mod_h264_streaming_plugin_init(plugin *p) {
+  p->version     = LIGHTTPD_VERSION_ID;
+  p->name        = buffer_init_string("h264_streaming");
+
+  p->init        = mod_h264_streaming_init;
+  p->handle_physical = mod_h264_streaming_path_handler;
+  p->set_defaults  = mod_h264_streaming_set_defaults;
+  p->cleanup     = mod_h264_streaming_free;
+
+  p->handle_trigger = mod_h264_streaming_trigger;
+
+  p->connection_reset = mod_h264_streaming_cleanup;
+  p->handle_connection_close = mod_h264_streaming_cleanup;
+
+  p->data        = NULL;
+
+  return 0;
+}
diff -Naur ../lighttpd-1.4.26.orig/src/mod_streaming_export.h ./src/mod_streaming_export.h
--- ../lighttpd-1.4.26.orig/src/mod_streaming_export.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mod_streaming_export.h	2010-06-03 15:36:00.858299808 +0200
@@ -0,0 +1,38 @@
+/*******************************************************************************
+ mod_streaming_export.h
+
+ Copyright (C) 2009-2010 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef MOD_STREAMING_EXPORT_H_AKW
+#define MOD_STREAMING_EXPORT_H_AKW
+
+#if defined _WIN32 || defined __CYGWIN__
+  #define MOD_STREAMING_DLL_IMPORT __declspec(dllimport)
+  #define MOD_STREAMING_DLL_EXPORT __declspec(dllexport)
+  #define MOD_STREAMING_DLL_LOCAL
+#else
+  #if __GNUC__ >= 4
+    #define MOD_STREAMING_DLL_IMPORT __attribute__ ((visibility("default")))
+    #define MOD_STREAMING_DLL_EXPORT __attribute__ ((visibility("default")))
+    #define MOD_STREAMING_DLL_LOCAL  __attribute__ ((visibility("hidden")))
+  #else
+    #define MOD_STREAMING_DLL_IMPORT
+    #define MOD_STREAMING_DLL_EXPORT
+    #define MOD_STREAMING_DLL_LOCAL
+  #endif
+#endif
+
+#define X_MOD_H264_STREAMING_KEY       "X-Mod-H264-Streaming"
+#define X_MOD_H264_STREAMING_VERSION   "version=2.2.9"
+
+#define X_MOD_SMOOTH_STREAMING_KEY     "X-Mod-Smooth-Streaming"
+#define X_MOD_SMOOTH_STREAMING_VERSION "version=1.0.9"
+
+#endif // MOD_STREAMING_EXPORT_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/moov.c ./src/moov.c
--- ../lighttpd-1.4.26.orig/src/moov.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/moov.c	2010-06-03 15:36:00.860307593 +0200
@@ -0,0 +1,441 @@
+/*******************************************************************************
+ moov.c - A library for splitting Quicktime/MPEG4.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define _CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+#endif
+
+#include "moov.h"
+#include "mp4_io.h"
+#include "mp4_reader.h"
+#include "output_bucket.h"
+#if defined(BUILDING_H264_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_mp4.h"
+#endif
+#if defined(BUILDING_SMOOTH_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_ismv.h"
+#endif
+#if defined(BUILDING_FLV_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_flv.h"
+#endif
+
+/* 
+  The QuickTime File Format PDF from Apple:
+    http://developer.apple.com/techpubs/quicktime/qtdevdocs/PDF/QTFileFormat.pdf
+    http://developer.apple.com/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <sys/stat.h>
+
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+
+#ifdef WIN32
+#define stat _stat64
+#define strdup _strdup
+#endif
+
+char const* fragment_type_audio = "audio";
+char const* fragment_type_video = "video";
+
+/* Returns true when the test string is a prefix of the input */
+int starts_with(const char* input, const char* test)
+{
+  while(*input && *test)
+  {
+    if(*input != *test)
+      return 0;
+    ++input;
+    ++test;
+  }
+
+  return *test == '\0';
+}
+
+/* Returns true when the test string is a suffix of the input */
+int ends_with(const char* input, const char* test)
+{
+  const char* it = input + strlen(input);
+  const char* pit = test + strlen(test);
+  while(it != input && pit != test)
+  {
+    if(*it != *pit)
+      return 0;
+    --it;
+    --pit;
+  }
+
+  return pit == test;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+// reported by everwanna:
+// av out of sync because: 
+// audio track 0 without stss, seek to the exact time. 
+// video track 1 with stss, seek to the nearest key frame time.
+//
+// fixed:
+// first pass we get the new aligned times for traks with an stss present
+// second pass is for traks without an stss
+static int get_aligned_start_and_end(struct mp4_context_t const* mp4_context,
+                                     unsigned int start, unsigned int end,
+                                     unsigned int* trak_sample_start,
+                                     unsigned int* trak_sample_end)
+{
+  unsigned int pass;
+  struct moov_t* moov = mp4_context->moov;
+  long moov_time_scale = moov->mvhd_->timescale_;
+
+  for(pass = 0; pass != 2; ++pass)
+  {
+    unsigned int i;
+    for(i = 0; i != moov->tracks_; ++i)
+    {
+      struct trak_t* trak = moov->traks_[i];
+      struct stbl_t* stbl = trak->mdia_->minf_->stbl_;
+      long trak_time_scale = trak->mdia_->mdhd_->timescale_;
+
+      // 1st pass: stss present, 2nd pass: no stss present
+      if(pass == 0 && !stbl->stss_)
+        continue;
+      if(pass == 1 && stbl->stss_)
+        continue;
+
+      // get start
+      if(start == 0)
+      {
+        trak_sample_start[i] = start;
+      }
+      else
+      {
+        start = stts_get_sample(stbl->stts_,
+          moov_time_to_trak_time(start, moov_time_scale, trak_time_scale));
+
+        MP4_INFO("start=%u (trac time)\n", start);
+        MP4_INFO("start=%.2f (seconds)\n",
+          stts_get_time(stbl->stts_, start) / (float)trak_time_scale);
+
+        start = stbl_get_nearest_keyframe(stbl, start + 1) - 1;
+        MP4_INFO("start=%u (zero based keyframe)\n", start);
+        trak_sample_start[i] = start;
+        start = (unsigned int)(trak_time_to_moov_time(
+          stts_get_time(stbl->stts_, start), moov_time_scale, trak_time_scale));
+        MP4_INFO("start=%u (moov time)\n", start);
+        MP4_INFO("start=%.2f (seconds)\n", start / (float)moov_time_scale);
+      }
+
+      // get end
+      if(end == 0)
+      {
+        // The default is till-the-end of the track
+        trak_sample_end[i] = trak->samples_size_;
+      }
+      else
+      {
+        end = stts_get_sample(stbl->stts_,
+          moov_time_to_trak_time(end, moov_time_scale, trak_time_scale));
+        MP4_INFO("end=%u (trac time)\n", end);
+        MP4_INFO("end=%.2f (seconds)\n",
+          stts_get_time(stbl->stts_, end) / (float)trak_time_scale);
+
+        if(end >= trak->samples_size_)
+        {
+          end = trak->samples_size_;
+        }
+        else
+        {
+          end = stbl_get_nearest_keyframe(stbl, end + 1) - 1;
+        }
+        MP4_INFO("end=%u (zero based keyframe)\n", end);
+        trak_sample_end[i] = end;
+//          MP4_INFO("endframe=%u, samples_size_=%u\n", end, trak->samples_size_);
+        end = (unsigned int)trak_time_to_moov_time(
+          stts_get_time(stbl->stts_, end), moov_time_scale, trak_time_scale);
+        MP4_INFO("end=%u (moov time)\n", end);
+        MP4_INFO("end=%.2f (seconds)\n", end / (float)moov_time_scale);
+      }
+    }
+  }
+
+  MP4_INFO("start=%u\n", start);
+  MP4_INFO("end=%u\n", end);
+
+  if(end && start >= end)
+  {
+    return 0;
+  }
+
+  return 1;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+mp4_split_options_t* mp4_split_options_init()
+{
+  mp4_split_options_t* options = (mp4_split_options_t*)
+    malloc(sizeof(mp4_split_options_t));
+  options->client_is_flash = 0;
+  options->start = 0.0;
+  options->start_integer = 0;
+  options->end = 0.0;
+  options->adaptive = 0;
+  options->fragments = 0;
+  options->output_format = OUTPUT_FORMAT_MP4;
+  options->input_format = INPUT_FORMAT_MP4;
+//  options->fragment_type = NULL;
+  options->audio_fragment_bitrate = 0;
+  options->video_fragment_bitrate = 0;
+  options->fragment_track_id = 0;
+  options->audio_fragment_start = UINT64_MAX;
+  options->video_fragment_start = UINT64_MAX;
+  options->seconds = 0;
+  options->byte_offsets = 0;
+
+  return options;
+}
+
+int mp4_split_options_set(struct mp4_split_options_t* options,
+                          const char* args_data,
+                          unsigned int args_size)
+{
+  int result = 1;
+
+  {
+    const char* first = args_data;
+    const char* last = first + args_size + 1;
+
+    if(*first == '?')
+    {
+      ++first;
+    }
+
+    {
+      char const* key = first;
+      char const* val = NULL;
+      int is_key = 1;
+      size_t key_len = 0;
+
+      float vbegin = 0.0f;
+      float vend = 0.0f;
+
+      unsigned int bitrate = 0;
+      char const* fragment_type = NULL;
+
+      while(first != last)
+      {
+        // the args_data is not necessarily 0 terminated, so fake it
+        int ch = (first == last - 1) ? '\0' : *first;
+        switch(ch)
+        {
+        case '=':
+          val = first + 1;
+          key_len = first - key;
+          is_key = 0;
+          break;
+        case '&':
+        case '\0':
+          if(!is_key)
+          {
+            // make sure the value is zero-terminated (for strtod,atoi64)
+            int val_len = first - val;
+            char* valz = (char*)malloc(val_len + 1);
+            memcpy(valz, val, val_len);
+            valz[val_len] = '\0';
+
+            if(!strncmp("client", key, key_len))
+            {
+              options->client_is_flash = starts_with(valz, "FLASH");
+            } else
+            if(!strncmp("start", key, key_len))
+            {
+              options->start = (float)(strtod(valz, NULL));
+              options->start_integer = atoi64(valz);
+            } else
+            if(!strncmp("end", key, key_len))
+            {
+              options->end = (float)(strtod(valz, NULL));
+            } else
+            if(!strncmp("vbegin", key, key_len))
+            {
+              vbegin = (float)(strtod(valz, NULL));
+            } else
+            if(!strncmp("vend", key, key_len))
+            {
+              vend = (float)(strtod(valz, NULL));
+            } else
+            if(!strncmp("adaptive", key, key_len))
+            {
+              options->adaptive = 1;
+            } else
+            if(!strncmp("bitrate", key, key_len))
+            {
+              bitrate = (unsigned int)(atoi64(valz));
+              if(fragment_type)
+              {
+                if(!strcmp(fragment_type, fragment_type_video))
+                {
+                  options->video_fragment_bitrate = bitrate;
+                } else
+                if(!strcmp(fragment_type, fragment_type_audio))
+                {
+                  options->audio_fragment_bitrate = bitrate;
+                }
+              }
+            } else
+            if(!strncmp("video", key, key_len))
+            {
+              options->fragments = 1;
+              fragment_type = fragment_type_video;
+              options->video_fragment_start = atoi64(valz);
+              if(bitrate)
+              {
+                options->video_fragment_bitrate = bitrate;
+              }
+            } else
+            if(!strncmp("audio", key, key_len))
+            {
+              options->fragments = 1;
+              fragment_type = fragment_type_audio;
+              options->audio_fragment_start = atoi64(valz);
+              if(bitrate)
+              {
+                options->audio_fragment_bitrate = bitrate;
+              }
+            } else
+            if(!strncmp("format", key, key_len))
+            {
+              if(!strncmp("flv", val, val_len))
+              {
+                options->output_format = OUTPUT_FORMAT_FLV;
+              } else
+              if(!strncmp("ts", val, val_len))
+              {
+                options->output_format = OUTPUT_FORMAT_TS;
+              }
+            } else
+            if(!strncmp("input", key, key_len))
+            {
+              if(!strncmp("flv", val, val_len))
+              {
+                options->input_format = INPUT_FORMAT_FLV;
+              }
+            }
+            free(valz);
+          }
+          key = first + 1;
+          val = NULL;
+          is_key = 1;
+          break;
+        }
+        ++first;
+      }
+
+      // If we have specified a begin point of the virtual video clip,
+      // then adjust the start offset
+      options->start += vbegin;
+
+      // If we have specified an end, adjust it in case of a virtual video clip.
+      if(options->end)
+      {
+        options->end += vbegin;
+      }
+      else
+      {
+        options->end = vend;
+      }
+
+      // Validate the start/end for the virtual video clip (begin).
+      if(vbegin)
+      {
+        if(options->start < vbegin)
+          result = 0;
+        if(options->end && options->end < vbegin)
+          result = 0;
+      }
+      // Validate the start/end for the virtual video clip (end).
+      if(vend)
+      {
+        if(options->start > vend)
+          result =  0;
+        if(options->end && options->end > vend)
+          result = 0;
+      }
+    }
+  }
+
+  return result;
+}
+
+void mp4_split_options_exit(struct mp4_split_options_t* options)
+{
+  if(options->byte_offsets)
+  {
+    free(options->byte_offsets);
+  }
+
+  free(options);
+}
+
+extern int mp4_split(struct mp4_context_t* mp4_context,
+                     unsigned int* trak_sample_start,
+                     unsigned int* trak_sample_end,
+                     mp4_split_options_t const* options)
+{
+  int result;
+
+  float start_time = options->start;
+  float end_time = options->end;
+
+  moov_build_index(mp4_context, mp4_context->moov);
+
+  {
+    struct moov_t const* moov = mp4_context->moov;
+    long moov_time_scale = moov->mvhd_->timescale_;
+    unsigned int start = (unsigned int)(start_time * moov_time_scale + 0.5f);
+    unsigned int end = (unsigned int)(end_time * moov_time_scale + 0.5f);
+
+    // for every trak, convert seconds to sample (time-to-sample).
+    // adjust sample to keyframe
+    result = get_aligned_start_and_end(mp4_context, start, end,
+                                       trak_sample_start, trak_sample_end);
+  }
+
+  return result;
+}
+
+uint64_t get_filesize(const char *path)
+{
+  struct stat status;
+  if(stat(path, &status))
+  {
+    printf("get_file_length(%s) stat: ", path);
+    perror(NULL);
+    return 0;
+  }
+  return status.st_size;
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/moov.h ./src/moov.h
--- ../lighttpd-1.4.26.orig/src/moov.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/moov.h	2010-06-03 15:36:00.861311625 +0200
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ moov.h - A library for splitting Quicktime/MPEG4 files.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef MOOV_H_AKW
+#define MOOV_H_AKW
+
+// NOTE: don't include stdio.h (for FILE) or sys/types.h (for off_t).
+// nginx redefines _FILE_OFFSET_BITS and off_t will have different sizes
+// depending on include order
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mp4_context_t;
+struct bucket_t;
+
+MOD_STREAMING_DLL_LOCAL extern char const* fragment_type_audio;
+MOD_STREAMING_DLL_LOCAL extern char const* fragment_type_video;
+
+enum fragment_type_t
+{
+  FRAGMENT_TYPE_UNKNOWN,
+  FRAGMENT_TYPE_AUDIO,
+  FRAGMENT_TYPE_VIDEO
+};
+
+enum input_format_t
+{
+  INPUT_FORMAT_MP4,
+  INPUT_FORMAT_FLV
+};
+typedef enum input_format_t input_format_t;
+
+enum output_format_t
+{
+  OUTPUT_FORMAT_MP4,
+  OUTPUT_FORMAT_MOV,
+  OUTPUT_FORMAT_RAW,
+  OUTPUT_FORMAT_FLV,
+  OUTPUT_FORMAT_TS
+};
+typedef enum output_format_t output_format_t;
+
+struct mp4_split_options_t
+{
+  int client_is_flash;
+  float start;
+  uint64_t start_integer;
+  float end;
+  int adaptive;
+  int fragments;
+  enum output_format_t output_format;
+  enum input_format_t input_format;
+//  char const* fragment_type;
+  unsigned int audio_fragment_bitrate;
+  unsigned int video_fragment_bitrate;
+  unsigned int fragment_track_id;
+  uint64_t audio_fragment_start;
+  uint64_t video_fragment_start;
+  int seconds;
+  uint64_t* byte_offsets;
+};
+typedef struct mp4_split_options_t mp4_split_options_t;
+
+MOD_STREAMING_DLL_LOCAL extern
+mp4_split_options_t* mp4_split_options_init();
+MOD_STREAMING_DLL_LOCAL extern
+int mp4_split_options_set(mp4_split_options_t* options,
+                          const char* args_data,
+                          unsigned int args_size);
+MOD_STREAMING_DLL_LOCAL extern
+void mp4_split_options_exit(mp4_split_options_t* options);
+
+/* Returns true when the test string is a prefix of the input */
+MOD_STREAMING_DLL_LOCAL extern
+int starts_with(const char* input, const char* test);
+/* Returns true when the test string is a suffix of the input */
+MOD_STREAMING_DLL_LOCAL extern
+int ends_with(const char* input, const char* test);
+
+MOD_STREAMING_DLL_LOCAL extern
+int mp4_split(struct mp4_context_t* mp4_context,
+              unsigned int* trak_sample_start,
+              unsigned int* trak_sample_end,
+              mp4_split_options_t const* options);
+
+MOD_STREAMING_DLL_LOCAL extern uint64_t get_filesize(const char *path);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // MOOV_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_io.c ./src/mp4_io.c
--- ../lighttpd-1.4.26.orig/src/mp4_io.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_io.c	2010-06-03 15:36:00.866331507 +0200
@@ -0,0 +1,2141 @@
+/*******************************************************************************
+ mp4_io.c - A library for general MPEG4 I/O.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef __cplusplus
+#define __STDC_FORMAT_MACROS // C++ should define this for PRIu64
+#define __STDC_LIMIT_MACROS  // C++ should define this for UINT32_MAX
+#endif
+
+#include "mp4_io.h"
+#include "mp4_reader.h" // for moov_read
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>  // FreeBSD doesn't define off_t in stdio.h
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+
+#ifdef WIN32
+#include <io.h>
+#include <windows.h>
+#define DIR_SEPARATOR '\\'
+#define strdup _strdup
+#define open _open
+#define close _close
+#define write _write
+#define lseek _lseeki64
+#define stat _stat64
+#else
+#define DIR_SEPARATOR '/'
+#include <unistd.h>
+#include <sys/mman.h>
+#endif
+
+extern uint64_t atoi64(const char* val)
+{
+#ifdef WIN32
+  return _atoi64(val);
+#else // elif defined(HAVE_STRTOLL)
+  return strtoll(val, NULL, 10);
+#endif
+}
+
+extern const char* remove_path(const char *path)
+{
+  const char* p = strrchr(path, DIR_SEPARATOR);
+  if(p != NULL && *p != '\0')
+  {
+    return p + 1;
+  }
+
+  return path;
+}
+
+extern void mp4_log_trace(const char* fmt, ...)
+{
+  va_list arglist;
+  va_start(arglist, fmt);
+
+  vprintf(fmt, arglist);
+
+  va_end(arglist);
+}
+
+static int64_t seconds_since_1970(void)
+{
+// #ifdef WIN32
+  return time(NULL);
+// #else
+//   struct timeval tv;
+//   gettimeofday(&tv, NULL);
+//   return 1000000 * (int64_t)tv.tv_sec + tv.tv_usec;
+// #endif
+}
+
+static int64_t seconds_since_1904(void)
+{
+  return seconds_since_1970() + 2082844800;
+}
+
+extern unsigned int read_8(unsigned char const* buffer)
+{
+  return buffer[0];
+}
+
+extern unsigned char* write_8(unsigned char* buffer, unsigned int v)
+{
+  buffer[0] = (uint8_t)v;
+
+  return buffer + 1;
+}
+
+extern uint16_t read_16(unsigned char const* buffer)
+{
+  return (buffer[0] << 8) |
+         (buffer[1] << 0);
+}
+
+extern unsigned char* write_16(unsigned char* buffer, unsigned int v)
+{
+  buffer[0] = (uint8_t)(v >> 8);
+  buffer[1] = (uint8_t)(v >> 0);
+
+  return buffer + 2;
+}
+
+extern unsigned int read_24(unsigned char const* buffer)
+{
+  return (buffer[0] << 16) |
+         (buffer[1] << 8) |
+         (buffer[2] << 0);
+}
+
+extern unsigned char* write_24(unsigned char* buffer, unsigned int v)
+{
+  buffer[0] = (uint8_t)(v >> 16);
+  buffer[1] = (uint8_t)(v >> 8);
+  buffer[2] = (uint8_t)(v >> 0);
+
+  return buffer + 3;
+}
+
+extern uint32_t read_32(unsigned char const* buffer)
+{
+  return (buffer[0] << 24) |
+         (buffer[1] << 16) |
+         (buffer[2] << 8) |
+         (buffer[3] << 0);
+}
+
+extern unsigned char* write_32(unsigned char* buffer, uint32_t v)
+{
+  buffer[0] = (uint8_t)(v >> 24);
+  buffer[1] = (uint8_t)(v >> 16);
+  buffer[2] = (uint8_t)(v >> 8);
+  buffer[3] = (uint8_t)(v >> 0);
+
+  return buffer + 4;
+}
+
+extern uint64_t read_64(unsigned char const* buffer)
+{
+  return ((uint64_t)(read_32(buffer)) << 32) + read_32(buffer + 4);
+}
+
+extern unsigned char* write_64(unsigned char* buffer, uint64_t v)
+{
+  write_32(buffer + 0, (uint32_t)(v >> 32));
+  write_32(buffer + 4, (uint32_t)(v >> 0));
+
+  return buffer + 8;
+}
+
+extern uint32_t read_n(unsigned char const* buffer, unsigned int n)
+{
+  switch(n)
+  {
+  case 8:
+    return read_8(buffer);
+  case 16:
+    return read_16(buffer);
+  case 24:
+    return read_24(buffer);
+  case 32:
+    return read_32(buffer);
+  default:
+    // program error
+    return 0;
+  }
+}
+
+extern unsigned char* write_n(unsigned char* buffer, unsigned int n, uint32_t v)
+{
+  switch(n)
+  {
+  case 8:
+    return write_8(buffer, v);
+  case 16:
+    return write_16(buffer, v);
+  case 24:
+    return write_24(buffer, v);
+  case 32:
+    return write_32(buffer, v);
+  }
+  return NULL;
+}
+
+static unsigned int alignment()
+{
+#ifdef _WIN32
+  SYSTEM_INFO SysInfo;
+  GetSystemInfo(&SysInfo);
+  return (unsigned int)(SysInfo.dwAllocationGranularity);
+#else
+  return (unsigned int)(getpagesize());
+#endif
+}
+
+static mem_range_t* mem_range_init(char const* filename, int read_only,
+                                   uint64_t filesize,
+                                   uint64_t offset, uint64_t len)
+{
+  mem_range_t* mem_range = (mem_range_t*)malloc(sizeof(mem_range_t));
+  mem_range->read_only_ = read_only;
+  mem_range->filesize_ = filesize;
+  mem_range->fd_ = -1;
+  mem_range->mmap_addr_ = 0;
+  mem_range->mmap_offset_ = 0;
+  mem_range->mmap_size_ = 0;
+#ifdef WIN32
+  mem_range->fileMapHandle_ = NULL;
+#endif
+
+  mem_range->fd_ = open(filename, read_only ? O_RDONLY : (O_RDWR | O_CREAT),
+#ifdef WIN32
+  S_IREAD | S_IWRITE
+#else
+  0666
+#endif
+  );
+  if(mem_range->fd_ == -1)
+  {
+    printf("mem_range: Error opening file %s\n", filename);
+    mem_range_exit(mem_range);
+    return 0;
+  }
+
+  if(!read_only)
+  {
+    // shrink the file (if necessary)
+    if(offset + len < filesize)
+    {
+      int result;
+#ifdef WIN32
+      lseek(mem_range->fd_, offset + len, SEEK_SET);
+      result =
+        SetEndOfFile((HANDLE)_get_osfhandle(mem_range->fd_)) == 0 ? -1 : 0;
+#else
+      result = truncate(filename, offset + len);
+#endif
+      if(result < 0)
+      {
+        printf("mem_range: Error shrinking file %s\n", filename);
+        mem_range_exit(mem_range);
+        return 0;
+      }
+    }
+    // stretch the file (if necessary)
+    else if(offset + len > filesize)
+    {
+      lseek(mem_range->fd_, offset + len - 1, SEEK_SET);
+      if(write(mem_range->fd_, "", 1) < 0)
+      {
+        printf("mem_range: Error stretching file %s\n", filename);
+        mem_range_exit(mem_range);
+        return 0;
+      }
+    }
+    mem_range->filesize_ = offset + len;
+  }
+
+#ifdef _WIN32
+{
+  HANDLE hFile = (HANDLE)_get_osfhandle(mem_range->fd_);
+
+  if(!hFile)
+  {
+    printf("%s", "Cannot create file mapping\n");
+    mem_range_exit(mem_range);
+    return 0;
+  }
+
+  mem_range->fileMapHandle_ = CreateFileMapping(hFile, 0,
+    read_only ? PAGE_READONLY : PAGE_READWRITE, 0, 0, NULL);
+
+  if(!mem_range->fileMapHandle_)
+  {
+    printf("%s", "Cannot create file mapping view\n");
+    mem_range_exit(mem_range);
+    return 0;
+  }
+}
+#endif
+
+  return mem_range;
+}
+
+mem_range_t* mem_range_init_read(char const* filename)
+{
+  int read_only = 1;
+  uint64_t offset = 0;
+  struct stat status;
+  // make sure regular file exists and its not empty (can't mmap 0 bytes)
+  if(stat(filename, &status) ||
+     (status.st_mode & S_IFMT) != S_IFREG ||
+     status.st_size == 0)
+  {
+    return 0;
+  }
+
+  return mem_range_init(filename, read_only, status.st_size,
+                        offset, status.st_size);
+}
+
+mem_range_t* mem_range_init_write(char const* filename,
+                                  uint64_t offset, uint64_t len)
+{
+  int read_only = 0;
+  uint64_t filesize = 0;
+  struct stat status;
+  if(!stat(filename, &status))
+  {
+    filesize = status.st_size;
+  }
+
+  return mem_range_init(filename, read_only, filesize, offset, len);
+}
+
+void* mem_range_map(mem_range_t* mem_range, uint64_t offset, uint32_t len)
+{
+  // only map when necessary
+  if(offset < mem_range->mmap_offset_ ||
+     offset + len >= mem_range->mmap_offset_ + mem_range->mmap_size_)
+  {
+    // use 1MB of overlap, so a little random access is okay at the end of the
+    // memory mapped file.
+    const unsigned int overlap = 1024 * 1024;
+    const unsigned int window_size = 16 * 1024 * 1024;
+
+    unsigned int dwSysGran = alignment();
+    uint64_t mmap_offset = offset > overlap ? (offset - overlap) : 0;
+    len += offset > overlap ? overlap : (uint32_t)offset;
+//    uint64_t mmap_offset = offset;
+    mem_range->mmap_offset_ = (mmap_offset / dwSysGran) * dwSysGran;
+    mem_range->mmap_size_ = (mmap_offset % dwSysGran) + len;
+
+    if(mem_range->mmap_offset_ + mem_range->mmap_size_ > mem_range->filesize_)
+    {
+      printf("%s", "mem_range_map: invalid range for file mapping\n");
+      return 0;
+    }
+
+    if(mem_range->mmap_size_ < window_size)
+    {
+      mem_range->mmap_size_ = window_size;
+    }
+
+    if(mem_range->mmap_offset_ + mem_range->mmap_size_ > mem_range->filesize_)
+    {
+      mem_range->mmap_size_ = mem_range->filesize_ - mem_range->mmap_offset_;
+    }
+
+//    printf("mem_range(%x): offset=%"PRIu64"\n", mem_range, offset);
+
+#ifdef WIN32
+    if(mem_range->mmap_addr_)
+    {
+      UnmapViewOfFile(mem_range->mmap_addr_);
+    }
+
+    mem_range->mmap_addr_ = MapViewOfFile(mem_range->fileMapHandle_,
+      mem_range->read_only_ ? FILE_MAP_READ : FILE_MAP_WRITE,
+      mem_range->mmap_offset_ >> 32, (uint32_t)(mem_range->mmap_offset_),
+      (size_t)(mem_range->mmap_size_));
+
+    if(!mem_range->mmap_addr_)
+    {
+      printf("%s", "Unable to make file mapping\n");
+      return 0;
+    }
+#else
+    if(mem_range->mmap_addr_)
+    {
+      munmap(mem_range->mmap_addr_, mem_range->mmap_size_);
+    }
+
+    mem_range->mmap_addr_ = mmap(0, mem_range->mmap_size_, mem_range->read_only_ ? PROT_READ : (PROT_READ | PROT_WRITE), mem_range->read_only_ ? MAP_PRIVATE : MAP_SHARED, mem_range->fd_, mem_range->mmap_offset_);
+
+    if(mem_range->mmap_addr_ == MAP_FAILED)
+    {
+      printf("%s", "Unable to make file mapping\n");
+      return 0;
+    }
+
+    if(mem_range->read_only_ &&
+       madvise(mem_range->mmap_addr_, mem_range->mmap_size_, MADV_SEQUENTIAL) < 0)
+    {
+      printf("%s", "Unable to advise file mapping\n");
+      // continue
+    }
+#endif
+  }
+
+  return (char*)mem_range->mmap_addr_ + (offset - mem_range->mmap_offset_);
+}
+
+void mem_range_exit(mem_range_t* mem_range)
+{
+  if(!mem_range)
+  {
+    return;
+  }
+
+#ifdef WIN32
+  CloseHandle(mem_range->fileMapHandle_);
+#endif
+
+  if(mem_range->mmap_addr_)
+  {
+#ifdef WIN32
+    UnmapViewOfFile(mem_range->mmap_addr_);
+#else
+    munmap(mem_range->mmap_addr_, mem_range->mmap_size_);
+#endif
+  }
+
+  if(mem_range->fd_ != -1)
+  {
+    close(mem_range->fd_);
+  }
+
+  free(mem_range);
+}
+
+extern int mp4_atom_read_header(mp4_context_t const* mp4_context,
+                                FILE* infile, mp4_atom_t* atom)
+{
+  unsigned char atom_header[8];
+
+  atom->start_ = ftello(infile);
+  if(fread(atom_header, 8, 1, infile) != 1)
+  {
+    MP4_ERROR("%s", "Error reading atom header\n");
+    return 0;
+  }
+  atom->short_size_ = read_32(&atom_header[0]);
+  atom->type_ = read_32(&atom_header[4]);
+
+  if(atom->short_size_ == 1)
+  {
+    if(fread(atom_header, 8, 1, infile) != 1)
+    {
+      MP4_ERROR("%s", "Error reading extended atom header\n");
+      return 0;
+    }
+    atom->size_ = read_64(&atom_header[0]);
+  }
+  else
+  {
+    atom->size_ = atom->short_size_;
+  }
+
+  atom->end_ = atom->start_ + atom->size_;
+
+  MP4_INFO("Atom(%c%c%c%c,%"PRIu64")\n",
+           atom->type_ >> 24, atom->type_ >> 16,
+           atom->type_ >> 8, atom->type_,
+           atom->size_);
+
+  if(atom->size_ < ATOM_PREAMBLE_SIZE)
+  {
+    MP4_ERROR("%s", "Error: invalid atom size\n");
+    return 0;
+  }
+
+  return 1;
+}
+
+extern int mp4_atom_write_header(unsigned char* outbuffer,
+                                 mp4_atom_t const* atom)
+{
+  int write_box64 = atom->short_size_ == 1 ? 1 : 0;
+
+  if(write_box64)
+    write_32(outbuffer, 1);
+  else
+    write_32(outbuffer, (uint32_t)atom->size_);
+
+  write_32(outbuffer + 4, atom->type_);
+
+  if(write_box64)
+  {
+    write_64(outbuffer + 8, atom->size_);
+    return 16;
+  }
+  else
+  {
+    return 8;
+  }
+}
+
+
+static unsigned char* read_box(struct mp4_context_t* mp4_context,
+                               FILE* infile, struct mp4_atom_t* atom)
+{
+  unsigned char* box_data = (unsigned char*)malloc((size_t)atom->size_);
+  fseeko(infile, atom->start_, SEEK_SET);
+  if(fread(box_data, (off_t)atom->size_, 1, infile) != 1)
+  {
+    MP4_ERROR("Error reading %c%c%c%c atom\n",
+           atom->type_ >> 24, atom->type_ >> 16,
+           atom->type_ >> 8, atom->type_);
+    free(box_data);
+    fclose(infile);
+    return 0;
+  }
+  return box_data;
+}
+
+static mp4_context_t* mp4_context_init(const char* filename, int verbose)
+{
+  mp4_context_t* mp4_context = (mp4_context_t*)malloc(sizeof(mp4_context_t));
+
+  mp4_context->filename_ = strdup(filename);
+  mp4_context->infile = NULL;
+  mp4_context->verbose_ = verbose;
+
+  memset(&mp4_context->ftyp_atom, 0, sizeof(struct mp4_atom_t));
+  memset(&mp4_context->moov_atom, 0, sizeof(struct mp4_atom_t));
+  memset(&mp4_context->mdat_atom, 0, sizeof(struct mp4_atom_t));
+  memset(&mp4_context->mfra_atom, 0, sizeof(struct mp4_atom_t));
+
+  mp4_context->moov_data = 0;
+  mp4_context->mfra_data = 0;
+
+  mp4_context->moov = 0;
+
+  return mp4_context;
+}
+
+static void mp4_context_exit(struct mp4_context_t* mp4_context)
+{
+  free(mp4_context->filename_);
+
+  if(mp4_context->infile)
+  {
+    fclose(mp4_context->infile);
+  }
+
+  if(mp4_context->moov_data)
+  {
+    free(mp4_context->moov_data);
+  }
+
+  if(mp4_context->mfra_data)
+  {
+    free(mp4_context->mfra_data);
+  }
+
+  if(mp4_context->moov)
+  {
+    moov_exit(mp4_context->moov);
+  }
+
+  free(mp4_context);
+}
+
+extern mp4_context_t* mp4_open(const char* filename, int64_t filesize,
+                               mp4_open_flags flags, int verbose)
+{
+  mp4_context_t* mp4_context = mp4_context_init(filename, verbose);
+
+  mp4_context->infile = fopen(filename, "rb");
+  if(mp4_context->infile == NULL)
+  {
+    mp4_context_exit(mp4_context);
+    return 0;
+  }
+
+  // fast-open if we're only interested in the mfra atom
+  if(flags == MP4_OPEN_MFRA)
+  {
+    unsigned char mfro[16];
+    fseeko(mp4_context->infile, -16, SEEK_END);
+    if(fread(mfro, 16, 1, mp4_context->infile) != 1)
+    {
+      MP4_ERROR("%s", "Error reading mfro header\n");
+      fseeko(mp4_context->infile, 0, SEEK_SET);
+    }
+    else
+    {
+      if(read_32(mfro + 4) != FOURCC('m', 'f', 'r', 'o'))
+      {
+        MP4_ERROR("%s", "Error parsing mfro header\n");
+        fseeko(mp4_context->infile, 0, SEEK_SET);
+      }
+      else
+      {
+        off_t mfra_size = read_32(mfro + 12);
+        fseeko(mp4_context->infile, -mfra_size, SEEK_END);
+      }
+    }
+  }
+
+  while(ftello(mp4_context->infile) < filesize)
+  {
+    struct mp4_atom_t leaf_atom;
+
+    if(!mp4_atom_read_header(mp4_context, mp4_context->infile, &leaf_atom))
+      break;
+
+    switch(leaf_atom.type_)
+    {
+    case FOURCC('f', 't', 'y', 'p'):
+      mp4_context->ftyp_atom = leaf_atom;
+      break;
+    case FOURCC('m', 'o', 'o', 'v'):
+      mp4_context->moov_atom = leaf_atom;
+      mp4_context->moov_data = read_box(mp4_context, mp4_context->infile, &mp4_context->moov_atom);
+      if(mp4_context->moov_data == NULL)
+      {
+        mp4_context_exit(mp4_context);
+        return 0;
+      }
+
+      mp4_context->moov = (moov_t*)
+        moov_read(mp4_context, NULL,
+                  mp4_context->moov_data + ATOM_PREAMBLE_SIZE,
+                  mp4_context->moov_atom.size_ - ATOM_PREAMBLE_SIZE);
+
+      if(mp4_context->moov == 0 || mp4_context->moov->mvhd_ == 0)
+      {
+        MP4_ERROR("%s", "Error parsing moov header\n");
+        mp4_context_exit(mp4_context);
+        return 0;
+      }
+      break;
+    case FOURCC('m', 'o', 'o', 'f'):
+      {
+        moof_t* moof;
+        unsigned char* moof_data =
+          read_box(mp4_context, mp4_context->infile, &leaf_atom);
+
+        mp4_context->moof_offset_ = leaf_atom.start_;
+
+#if 1
+        // Check for Expression Encoder file (missing mandatory stco)
+        if(mp4_context->moov != 0 &&
+           mp4_context->moov->tracks_ != 0 &&
+           mp4_context->moov->traks_[0]->mdia_->minf_->stbl_->stco_ == 0)
+        {
+          MP4_ERROR("%s", "Fixing invalid offsets for Expression Encoder file\n");
+          // Expression Encoder doesn't write a base_data_offset or data_offset.
+          // We patch the moof_offset_ to point to the mdat following the moof.
+          mp4_context->moof_offset_ += leaf_atom.size_ + ATOM_PREAMBLE_SIZE;
+        }
+#endif
+
+        moof = (moof_t*)
+          moof_read(mp4_context, NULL,
+                    moof_data + ATOM_PREAMBLE_SIZE,
+                    leaf_atom.size_ - ATOM_PREAMBLE_SIZE);
+
+        free(moof_data);
+
+        if(moof == 0)
+        {
+          MP4_ERROR("%s", "Error parsing moof header\n");
+          mp4_context_exit(mp4_context);
+          return 0;
+        }
+
+        moof_exit(moof);
+      }
+      break;
+    case FOURCC('m', 'd', 'a', 't'):
+      mp4_context->mdat_atom = leaf_atom;
+      break;
+    case FOURCC('m', 'f', 'r', 'a'):
+      mp4_context->mfra_atom = leaf_atom;
+      mp4_context->mfra_data = read_box(mp4_context, mp4_context->infile, &mp4_context->mfra_atom);
+      if(mp4_context->mfra_data == NULL)
+      {
+        mp4_context_exit(mp4_context);
+        return 0;
+      }
+      break;
+    }
+
+    if(leaf_atom.end_ > (uint64_t)filesize)
+    {
+      MP4_ERROR("%s", "Reached end of file prematurely\n");
+      mp4_context_exit(mp4_context);
+      return 0;
+    }
+
+    fseeko(mp4_context->infile, leaf_atom.end_, SEEK_SET);
+
+    // short-circuit for mfra. We only need the mfra atom.
+    if((flags == MP4_OPEN_MOOV) && mp4_context->moov_atom.size_)
+    {
+      return mp4_context;
+    }
+
+    // short-circuit for mfra. We only need the mfra atom.
+    if((flags == MP4_OPEN_MFRA) && mp4_context->mfra_atom.size_)
+    {
+      return mp4_context;
+    }
+  }
+
+  if(mp4_context->moov == 0)
+  {
+    MP4_ERROR("%s", "Error: moov atom not found\n");
+    mp4_context_exit(mp4_context);
+    return 0;
+  }
+
+  if(mp4_context->mdat_atom.size_ == 0)
+  {
+    // or mdat atom
+    MP4_ERROR("%s", "Error: mdat atom not found\n");
+    mp4_context_exit(mp4_context);
+    return 0;
+  }
+
+  return mp4_context;
+}
+
+extern void mp4_close(struct mp4_context_t* mp4_context)
+{
+  mp4_context_exit(mp4_context);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+extern struct unknown_atom_t* unknown_atom_init()
+{
+  unknown_atom_t* atom = (unknown_atom_t*)malloc(sizeof(unknown_atom_t));
+  atom->atom_ = 0;
+  atom->next_ = 0;
+
+  return atom;
+}
+
+extern void unknown_atom_exit(unknown_atom_t* atom)
+{
+  while(atom)
+  {
+    unknown_atom_t* next = atom->next_;
+    free(atom->atom_);
+    free(atom);
+    atom = next;
+  }
+}
+
+
+extern moov_t* moov_init()
+{
+  moov_t* moov = (moov_t*)malloc(sizeof(moov_t));
+  moov->unknown_atoms_ = 0;
+  moov->mvhd_ = 0;
+  moov->tracks_ = 0;
+  moov->mvex_ = 0;
+
+  moov->is_indexed_ = 0;
+
+  return moov;
+}
+
+extern void moov_exit(moov_t* atom)
+{
+  unsigned int i;
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  if(atom->mvhd_)
+  {
+    mvhd_exit(atom->mvhd_);
+  }
+  for(i = 0; i != atom->tracks_; ++i)
+  {
+    trak_exit(atom->traks_[i]);
+  }
+  if(atom->mvex_)
+  {
+    mvex_exit(atom->mvex_);
+  }
+  free(atom);
+}
+
+extern trak_t* moov_get_track(moov_t* moov, unsigned int track_id)
+{
+  unsigned int i;
+
+  for(i = 0; i != moov->tracks_; ++i)
+  {
+    trak_t* trak = moov->traks_[i];
+    if(trak->tkhd_->track_id_ == track_id)
+    {
+      return trak;
+    }
+  }
+
+  return NULL;
+}
+
+#if 0
+extern void moov_shift_offsets(moov_t* moov, int64_t offset)
+{
+  unsigned int i;
+  for(i = 0; i != moov->tracks_; ++i)
+  {
+    trak_shift_offsets(moov->traks_[i], offset);
+  }
+}
+#endif
+
+extern trak_t* trak_init()
+{
+  trak_t* trak = (trak_t*)malloc(sizeof(trak_t));
+  trak->unknown_atoms_ = 0;
+  trak->tkhd_ = 0;
+  trak->mdia_ = 0;
+  trak->edts_ = 0;
+  trak->chunks_size_ = 0;
+  trak->chunks_ = 0;
+  trak->samples_size_ = 0;
+  trak->samples_ = 0;
+
+//  trak->fragment_pts_ = 0;
+
+  return trak;
+}
+
+extern unsigned int trak_bitrate(trak_t const* trak)
+{
+  long trak_time_scale = trak->mdia_->mdhd_->timescale_;
+  uint64_t duration;
+  unsigned int bps;
+
+  samples_t const* first = trak->samples_;
+  samples_t const* last = trak->samples_ + trak->samples_size_;
+  uint64_t sample_size = 0;
+  while(first != last)
+  {
+    sample_size += first->size_;
+    ++first;
+  }
+  duration = first->pts_;
+
+  bps = (unsigned int)(sample_size * trak_time_scale / duration * 8);
+
+  return bps;
+}
+
+#if 0
+extern void trak_shift_offsets(trak_t* trak, int64_t offset)
+{
+  stco_t* stco = trak->mdia_->minf_->stbl_->stco_;
+  stco_shift_offsets(stco, (int32_t)offset);
+}
+#endif
+
+extern void trak_exit(trak_t* trak)
+{
+  if(trak->unknown_atoms_)
+  {
+    unknown_atom_exit(trak->unknown_atoms_);
+  }
+  if(trak->tkhd_)
+  {
+    tkhd_exit(trak->tkhd_);
+  }
+  if(trak->mdia_)
+  {
+    mdia_exit(trak->mdia_);
+  }
+  if(trak->edts_)
+  {
+    edts_exit(trak->edts_);
+  }
+  if(trak->chunks_)
+  {
+    free(trak->chunks_);
+  }
+  if(trak->samples_)
+  {
+    free(trak->samples_);
+  }
+  free(trak);
+}
+
+extern mvhd_t* mvhd_init()
+{
+  unsigned int i;
+  mvhd_t* atom = (mvhd_t*)malloc(sizeof(mvhd_t));
+
+  atom->version_ = 1;
+  atom->flags_ = 0;
+  atom->creation_time_ =
+  atom->modification_time_ = seconds_since_1904();
+  atom->timescale_ = 10000000;
+  atom->duration_ = 0;
+  atom->rate_ = (1 << 16);
+  atom->volume_ = (1 << 8);
+  atom->reserved1_ = 0;
+  for(i = 0; i != 2; ++i)
+  {
+    atom->reserved2_[i] = 0;
+  }
+  for(i = 0; i != 9; ++i)
+  {
+    atom->matrix_[i] = 0;
+  }
+  atom->matrix_[0] = 0x00010000;
+  atom->matrix_[4] = 0x00010000;
+  atom->matrix_[8] = 0x40000000;
+  for(i = 0; i != 6; ++i)
+  {
+    atom->predefined_[i] = 0;
+  }
+  atom->next_track_id_ = 1;
+
+  return atom;
+}
+
+extern mvhd_t* mvhd_copy(mvhd_t const* rhs)
+{
+  mvhd_t* atom = (mvhd_t*)malloc(sizeof(mvhd_t));
+
+  memcpy(atom, rhs, sizeof(mvhd_t));
+
+  return atom;
+}
+
+extern void mvhd_exit(mvhd_t* atom)
+{
+  free(atom);
+}
+
+extern tkhd_t* tkhd_init()
+{
+  unsigned int i;
+  tkhd_t* tkhd = (tkhd_t*)malloc(sizeof(tkhd_t));
+
+  tkhd->version_= 1;
+  tkhd->flags_ = 7;           // track_enabled, track_in_movie, track_in_preview
+  tkhd->creation_time_ =
+  tkhd->modification_time_ = seconds_since_1904();
+  tkhd->track_id_ = 0;
+  tkhd->reserved_ = 0;
+  tkhd->duration_ = 0;
+  for(i = 0; i != 2; ++i)
+  {
+    tkhd->reserved2_[i] = 0;
+  }
+  tkhd->layer_ = 0;
+  tkhd->predefined_ = 0;
+  tkhd->volume_ = (1 << 8) + 0;
+  tkhd->reserved3_ = 0;
+  for(i = 0; i != 9; ++i)
+  {
+    tkhd->matrix_[i] = 0;
+  }
+  tkhd->matrix_[0] = 0x00010000;
+  tkhd->matrix_[4] = 0x00010000;
+  tkhd->matrix_[8] = 0x40000000;
+  tkhd->width_ = 0;
+  tkhd->height_ = 0;
+
+  return tkhd;
+}
+
+extern struct tkhd_t* tkhd_copy(tkhd_t const* rhs)
+{
+  tkhd_t* tkhd = (tkhd_t*)malloc(sizeof(tkhd_t));
+
+  memcpy(tkhd, rhs, sizeof(tkhd_t));
+
+  return tkhd;
+}
+
+extern void tkhd_exit(tkhd_t* tkhd)
+{
+  free(tkhd);
+}
+
+extern struct mdia_t* mdia_init()
+{
+  mdia_t* atom = (mdia_t*)malloc(sizeof(mdia_t));
+  atom->unknown_atoms_ = 0;
+  atom->mdhd_ = 0;
+  atom->hdlr_ = 0;
+  atom->minf_ = 0;
+
+  return atom;
+}
+
+extern void mdia_exit(mdia_t* atom)
+{
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  if(atom->mdhd_)
+  {
+    mdhd_exit(atom->mdhd_);
+  }
+  if(atom->hdlr_)
+  {
+    hdlr_exit(atom->hdlr_);
+  }
+  if(atom->minf_)
+  {
+    minf_exit(atom->minf_);
+  }
+  free(atom);
+}
+
+extern elst_t* elst_init()
+{
+  elst_t* elst = (elst_t*)malloc(sizeof(elst_t));
+
+  elst->version_ = 1;
+  elst->flags_ = 0;
+  elst->entry_count_ = 0;
+  elst->table_ = 0;
+
+  return elst;
+}
+
+extern void elst_exit(elst_t* elst)
+{
+  if(elst->table_)
+  {
+    free(elst->table_);
+  }
+  free(elst);
+}
+
+extern edts_t* edts_init()
+{
+  edts_t* edts = (edts_t*)malloc(sizeof(edts_t));
+
+  edts->unknown_atoms_ = 0;
+  edts->elst_ = 0;
+
+  return edts;
+}
+
+extern void edts_exit(edts_t* edts)
+{
+  if(edts->unknown_atoms_)
+  {
+    unknown_atom_exit(edts->unknown_atoms_);
+  }
+  if(edts->elst_)
+  {
+    elst_exit(edts->elst_);
+  }
+  free(edts);
+}
+
+extern mdhd_t* mdhd_init()
+{
+  unsigned int i;
+  mdhd_t* mdhd = (mdhd_t*)malloc(sizeof(mdhd_t));
+
+  mdhd->version_ = 1;
+  mdhd->flags_ = 0;
+  mdhd->creation_time_ =
+  mdhd->modification_time_ = seconds_since_1904();
+  mdhd->timescale_ = 10000000;
+  mdhd->duration_ = 0;
+  for(i = 0; i != 3; ++i)
+  {
+    mdhd->language_[i] = 0x7f;
+  }
+  mdhd->predefined_ = 0;
+
+  return mdhd;
+}
+
+extern mdhd_t* mdhd_copy(mdhd_t const* rhs)
+{
+  struct mdhd_t* mdhd = (struct mdhd_t*)malloc(sizeof(struct mdhd_t));
+
+  memcpy(mdhd, rhs, sizeof(mdhd_t));
+
+  return mdhd;
+}
+
+extern void mdhd_exit(struct mdhd_t* mdhd)
+{
+  free(mdhd);
+}
+
+extern hdlr_t* hdlr_init()
+{
+  hdlr_t* atom = (hdlr_t*)malloc(sizeof(hdlr_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->predefined_ = 0;
+  atom->handler_type_ = 0;
+  atom->reserved1_ = 0;
+  atom->reserved2_ = 0;
+  atom->reserved3_ = 0;
+  atom->name_ = 0;
+
+  return atom;
+}
+
+extern hdlr_t* hdlr_copy(hdlr_t const* rhs)
+{
+  hdlr_t* atom = (hdlr_t*)malloc(sizeof(hdlr_t));
+
+  atom->version_ = rhs->version_;
+  atom->flags_ = rhs->flags_;
+  atom->predefined_ = rhs->predefined_;
+  atom->handler_type_ = rhs->handler_type_;
+  atom->reserved1_ = rhs->reserved1_;
+  atom->reserved2_ = rhs->reserved2_;
+  atom->reserved3_ = rhs->reserved3_;
+  atom->name_ = rhs->name_ == NULL ? NULL : strdup(rhs->name_);
+
+  return atom;
+}
+
+extern void hdlr_exit(struct hdlr_t* atom)
+{
+  if(atom->name_)
+  {
+    free(atom->name_);
+  }
+  free(atom);
+}
+
+extern struct minf_t* minf_init()
+{
+  struct minf_t* atom = (struct minf_t*)malloc(sizeof(struct minf_t));
+  atom->unknown_atoms_ = 0;
+  atom->vmhd_ = 0;
+  atom->smhd_ = 0;
+  atom->dinf_ = 0;
+  atom->stbl_ = 0;
+
+  return atom;
+}
+
+extern void minf_exit(struct minf_t* atom)
+{
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  if(atom->vmhd_)
+  {
+    vmhd_exit(atom->vmhd_);
+  }
+  if(atom->smhd_)
+  {
+    smhd_exit(atom->smhd_);
+  }
+  if(atom->dinf_)
+  {
+    dinf_exit(atom->dinf_);
+  }
+  if(atom->stbl_)
+  {
+    stbl_exit(atom->stbl_);
+  }
+  free(atom);
+}
+
+extern vmhd_t* vmhd_init()
+{
+  unsigned int i;
+  vmhd_t* atom = (vmhd_t*)malloc(sizeof(vmhd_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 1;
+  atom->graphics_mode_ = 0;
+  for(i = 0; i != 3; ++i)
+  {
+    atom->opcolor_[i] = 0;
+  }
+
+  return atom;
+}
+
+extern vmhd_t* vmhd_copy(vmhd_t* rhs)
+{
+  vmhd_t* atom = (vmhd_t*)malloc(sizeof(vmhd_t));
+
+  memcpy(atom, rhs, sizeof(vmhd_t));
+
+  return atom;
+}
+
+extern void vmhd_exit(struct vmhd_t* atom)
+{
+  free(atom);
+}
+
+extern smhd_t* smhd_init()
+{
+  smhd_t* atom = (smhd_t*)malloc(sizeof(smhd_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->balance_ = 0;
+  atom->reserved_ = 0;
+
+  return atom;
+}
+
+extern smhd_t* smhd_copy(smhd_t* rhs)
+{
+  smhd_t* atom = (smhd_t*)malloc(sizeof(smhd_t));
+
+  memcpy(atom, rhs, sizeof(smhd_t));
+
+  return atom;
+}
+
+extern void smhd_exit(struct smhd_t* atom)
+{
+  free(atom);
+}
+
+extern dinf_t* dinf_init()
+{
+  dinf_t* atom = (dinf_t*)malloc(sizeof(dinf_t));
+
+  atom->dref_ = 0;
+
+  return atom;
+}
+
+extern dinf_t* dinf_copy(dinf_t* rhs)
+{
+  dinf_t* atom = (dinf_t*)malloc(sizeof(dinf_t));
+
+  atom->dref_ = dref_copy(rhs->dref_);
+
+  return atom;
+}
+
+extern void dinf_exit(dinf_t* atom)
+{
+  if(atom->dref_)
+  {
+    dref_exit(atom->dref_);
+  }
+  free(atom);
+}
+
+extern dref_t* dref_init()
+{
+  dref_t* atom = (dref_t*)malloc(sizeof(dref_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entry_count_ = 0;
+  atom->table_ = 0;
+
+  return atom;
+}
+
+extern dref_t* dref_copy(dref_t const* rhs)
+{
+  unsigned int i;
+  dref_t* atom = (dref_t*)malloc(sizeof(dref_t));
+
+  atom->version_ = rhs->version_;
+  atom->flags_ = rhs->flags_;
+  atom->entry_count_ = rhs->entry_count_;
+  atom->table_ = atom->entry_count_ == 0 ? NULL : (dref_table_t*)malloc(atom->entry_count_ * sizeof(dref_table_t));
+  for(i = 0; i != atom->entry_count_; ++i)
+  {
+    dref_table_assign(&atom->table_[i], &rhs->table_[i]);
+  }
+
+  return atom;
+}
+
+extern void dref_exit(dref_t* atom)
+{
+  unsigned int i;
+  for(i = 0; i != atom->entry_count_; ++i)
+  {
+    dref_table_exit(&atom->table_[i]);
+  }
+  if(atom->table_)
+  {
+    free(atom->table_);
+  }
+  free(atom);
+}
+
+extern void dref_table_init(dref_table_t* entry)
+{
+  entry->flags_ = 0;
+  entry->name_ = 0;
+  entry->location_ = 0;
+}
+
+extern void dref_table_assign(dref_table_t* lhs, dref_table_t const* rhs)
+{
+  lhs->flags_ = rhs->flags_;
+  lhs->name_ = rhs->name_ == NULL ? NULL : strdup(rhs->name_);
+  lhs->location_ = rhs->location_ == NULL ? NULL : strdup(rhs->location_);
+}
+
+extern void dref_table_exit(dref_table_t* entry)
+{
+  if(entry->name_)
+  {
+    free(entry->name_);
+  }
+  if(entry->location_)
+  {
+    free(entry->location_);
+  }
+}
+
+extern struct stbl_t* stbl_init()
+{
+  struct stbl_t* atom = (struct stbl_t*)malloc(sizeof(struct stbl_t));
+  atom->unknown_atoms_ = 0;
+  atom->stsd_ = 0;
+  atom->stts_ = 0;
+  atom->stss_ = 0;
+  atom->stsc_ = 0;
+  atom->stsz_ = 0;
+  atom->stco_ = 0;
+  atom->ctts_ = 0;
+
+  return atom;
+}
+
+extern void stbl_exit(struct stbl_t* atom)
+{
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  if(atom->stsd_)
+  {
+    stsd_exit(atom->stsd_);
+  }
+  if(atom->stts_)
+  {
+    stts_exit(atom->stts_);
+  }
+  if(atom->stss_)
+  {
+    stss_exit(atom->stss_);
+  }
+  if(atom->stsc_)
+  {
+    stsc_exit(atom->stsc_);
+  }
+  if(atom->stsz_)
+  {
+    stsz_exit(atom->stsz_);
+  }
+  if(atom->stco_)
+  {
+    stco_exit(atom->stco_);
+  }
+  if(atom->ctts_)
+  {
+    ctts_exit(atom->ctts_);
+  }
+
+  free(atom);
+}
+
+extern unsigned int stbl_get_nearest_keyframe(struct stbl_t const* stbl,
+                                              unsigned int sample)
+{
+  // If the sync atom is not present, all samples are implicit sync samples.
+  if(!stbl->stss_)
+    return sample;
+
+  return stss_get_nearest_keyframe(stbl->stss_, sample);
+}
+
+extern stsd_t* stsd_init()
+{
+  stsd_t* atom = (stsd_t*)malloc(sizeof(stsd_t));
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entries_ = 0;
+  atom->sample_entries_ = 0;
+
+  return atom;
+}
+
+extern stsd_t* stsd_copy(stsd_t const* rhs)
+{
+  unsigned int i;
+  struct stsd_t* atom = (struct stsd_t*)malloc(sizeof(struct stsd_t));
+
+  atom->version_ = rhs->version_;
+  atom->flags_ = rhs->flags_;
+  atom->entries_ = rhs->entries_;
+  atom->sample_entries_ =
+    (sample_entry_t*)malloc(atom->entries_ * sizeof(sample_entry_t));
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    sample_entry_assign(&atom->sample_entries_[i], &rhs->sample_entries_[i]);
+  }
+
+  return atom;
+}
+
+extern void stsd_exit(struct stsd_t* atom)
+{
+  unsigned int i;
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    sample_entry_t* sample_entry = &atom->sample_entries_[i];
+    sample_entry_exit(sample_entry);
+  }
+  if(atom->sample_entries_)
+  {
+    free(atom->sample_entries_);
+  }
+  free(atom);
+}
+
+extern video_sample_entry_t* video_sample_entry_init()
+{
+  video_sample_entry_t* video_sample_entry =
+    (video_sample_entry_t*)malloc(sizeof(video_sample_entry_t));
+
+  video_sample_entry->version_ = 0;
+  video_sample_entry->revision_level_ = 0;
+  video_sample_entry->vendor_ = 0;
+  video_sample_entry->temporal_quality_ = 0;
+  video_sample_entry->spatial_quality_ = 0;
+  video_sample_entry->width_ = 0;
+  video_sample_entry->height_ = 0;
+  video_sample_entry->horiz_resolution_ = (72 << 16);
+  video_sample_entry->vert_resolution_ = (72 << 16);
+  video_sample_entry->data_size_ = 0;
+  video_sample_entry->frame_count_ = 1;
+  memset(video_sample_entry->compressor_name_, 0, 32);
+  video_sample_entry->depth_ = 24;
+  video_sample_entry->color_table_id_ = -1;
+
+  return video_sample_entry;
+}
+
+extern audio_sample_entry_t* audio_sample_entry_init()
+{
+  audio_sample_entry_t* audio_sample_entry =
+    (audio_sample_entry_t*)malloc(sizeof(audio_sample_entry_t));
+
+  audio_sample_entry->version_ = 0;
+  audio_sample_entry->revision_ = 0;
+  audio_sample_entry->vendor_ = 0;
+  audio_sample_entry->channel_count_ = 2;
+  audio_sample_entry->sample_size_ = 16;
+  audio_sample_entry->compression_id_ = 0;
+  audio_sample_entry->packet_size_ = 0;
+  audio_sample_entry->samplerate_ = (0 << 16);
+
+  return audio_sample_entry;
+}
+
+extern void sample_entry_init(sample_entry_t* sample_entry)
+{
+  sample_entry->len_ = 0;
+  sample_entry->buf_ = 0;
+  sample_entry->codec_private_data_length_ = 0;
+  sample_entry->codec_private_data_ = 0;
+
+  sample_entry->video_= 0;
+  sample_entry->audio_ = 0;
+//sample_entry->hint_ = 0;
+
+  sample_entry->nal_unit_length_ = 0;
+  sample_entry->sps_length_ = 0;
+  sample_entry->sps_ = 0;
+  sample_entry->pps_length_ = 0;
+  sample_entry->pps_ = 0;
+
+  sample_entry->wFormatTag = 0;
+  sample_entry->nChannels = 2;
+  sample_entry->nSamplesPerSec = 44100;
+  sample_entry->nAvgBytesPerSec = 0;
+  sample_entry->nBlockAlign = 0;
+  sample_entry->wBitsPerSample = 16;
+
+  sample_entry->max_bitrate_ = 0;
+  sample_entry->avg_bitrate_ = 0;
+}
+
+extern void sample_entry_assign(sample_entry_t* lhs, sample_entry_t const* rhs)
+{
+  memcpy(lhs, rhs, sizeof(sample_entry_t));
+  if(rhs->buf_ != NULL)
+  {
+    lhs->buf_ = (unsigned char*)malloc(rhs->len_);
+    memcpy(lhs->buf_, rhs->buf_, rhs->len_);
+  }
+}
+
+extern void sample_entry_exit(sample_entry_t* sample_entry)
+{
+  if(sample_entry->buf_)
+  {
+    free(sample_entry->buf_);
+  }
+
+  if(sample_entry->video_)
+  {
+    free(sample_entry->video_);
+  }
+  if(sample_entry->audio_)
+  {
+    free(sample_entry->audio_);
+  }
+}
+
+static const uint32_t aac_samplerates[] =
+{
+  96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,
+  16000, 12000, 11025,  8000,  7350,     0,     0,     0
+};
+
+static const uint32_t aac_channels[] =
+{
+  0, 1, 2, 3, 4, 5, 6, 8,
+  0, 0, 0, 0, 0, 0, 0, 0
+};
+
+static int mp4_samplerate_to_index(unsigned int samplerate)
+{
+  unsigned int i;
+  for(i = 0; i != 13; ++i)
+  {
+    if(aac_samplerates[i] == samplerate)
+      return i;
+  }
+  return 4;
+}
+
+// Create an ADTS frame header
+extern void sample_entry_get_adts(sample_entry_t const* sample_entry,
+                                  unsigned int sample_size, uint8_t* buf)
+{
+  unsigned int syncword = 0xfff;
+  unsigned int ID = 0; // MPEG-4
+  unsigned int layer = 0;
+  unsigned int protection_absent = 1;
+  // 0 = Main profile AAC MAIN
+  // 1 = Low Complexity profile (LC) AAC LC
+  // 2 = Scalable Sample Rate profile (SSR) AAC SSR
+  // 3 = (reserved) AAC LTP
+  unsigned int profile = 1;
+  unsigned int sampling_frequency_index =
+    mp4_samplerate_to_index(sample_entry->nSamplesPerSec);
+  unsigned int private_bit = 0;
+  unsigned int channel_configuration = sample_entry->nChannels;
+  unsigned int original_copy = 0;
+  unsigned int home = 0;
+  unsigned int copyright_identification_bit = 0;
+  unsigned int copyright_identification_start = 0;
+  unsigned int aac_frame_length = 7 + sample_size;
+  unsigned int adts_buffer_fullness = 0x7ff;
+  unsigned int no_raw_data_blocks_in_frame = 0;
+  unsigned char buffer[8];
+
+  uint64_t adts = 0;
+  adts = (adts << 12) | syncword;
+  adts = (adts << 1) | ID;
+  adts = (adts << 2) | layer;
+  adts = (adts << 1) | protection_absent;
+  adts = (adts << 2) | profile;
+  adts = (adts << 4) | sampling_frequency_index;
+  adts = (adts << 1) | private_bit;
+  adts = (adts << 3) | channel_configuration;
+  adts = (adts << 1) | original_copy;
+  adts = (adts << 1) | home;
+  adts = (adts << 1) | copyright_identification_bit;
+  adts = (adts << 1) | copyright_identification_start;
+  adts = (adts << 13) | aac_frame_length;
+  adts = (adts << 11) | adts_buffer_fullness;
+  adts = (adts << 2) | no_raw_data_blocks_in_frame;
+
+  write_64(buffer, adts);
+
+  memcpy(buf, buffer + 1, 7);
+}
+
+extern stts_t* stts_init()
+{
+  stts_t* atom = (stts_t*)malloc(sizeof(stts_t));
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entries_ = 0;
+  atom->table_ = 0;
+
+  return atom;
+}
+
+extern void stts_exit(struct stts_t* atom)
+{
+  if(atom->table_)
+  {
+    free(atom->table_);
+  }
+  free(atom);
+}
+
+extern unsigned int stts_get_sample(struct stts_t const* stts, uint64_t time)
+{
+  unsigned int stts_index = 0;
+  unsigned int stts_count;
+
+  unsigned int ret = 0;
+  uint64_t time_count = 0;
+
+  for(; stts_index != stts->entries_; ++stts_index)
+  {
+    unsigned int sample_count = stts->table_[stts_index].sample_count_;
+    unsigned int sample_duration = stts->table_[stts_index].sample_duration_;
+    if(time_count + (uint64_t)sample_duration * (uint64_t)sample_count >= time)
+    {
+      stts_count = (unsigned int)((time - time_count + sample_duration - 1) / sample_duration);
+      time_count += (uint64_t)stts_count * (uint64_t)sample_duration;
+      ret += stts_count;
+      break;
+    }
+    else
+    {
+      time_count += (uint64_t)sample_duration * (uint64_t)sample_count;
+      ret += sample_count;
+    }
+  }
+  return ret;
+}
+
+extern uint64_t stts_get_time(struct stts_t const* stts, unsigned int sample)
+{
+  uint64_t ret = 0;
+  unsigned int stts_index = 0;
+  unsigned int sample_count = 0;
+  
+  for(;;)
+  {
+    unsigned int table_sample_count = stts->table_[stts_index].sample_count_;
+    unsigned int table_sample_duration = stts->table_[stts_index].sample_duration_;
+    if(sample_count + table_sample_count > sample)
+    {
+      unsigned int stts_count = (sample - sample_count);
+      ret += (uint64_t)stts_count * (uint64_t)table_sample_duration;
+      break;
+    }
+    else
+    {
+      sample_count += table_sample_count;
+      ret += (uint64_t)table_sample_count * (uint64_t)table_sample_duration;
+      stts_index++;
+    }
+  }
+  return ret;
+}
+
+extern uint64_t stts_get_duration(struct stts_t const* stts)
+{
+  uint64_t duration = 0;
+  unsigned int i;
+  for(i = 0; i != stts->entries_; ++i)
+  {
+    unsigned int sample_count = stts->table_[i].sample_count_;
+    unsigned int sample_duration = stts->table_[i].sample_duration_;
+    duration += (uint64_t)sample_duration * (uint64_t)sample_count;
+  }
+
+  return duration;
+}
+
+extern unsigned int stts_get_samples(struct stts_t const* stts)
+{
+  unsigned int samples = 0;
+  unsigned int entries = stts->entries_;
+  unsigned int i;
+  for(i = 0; i != entries; ++i)
+  {
+    unsigned int sample_count = stts->table_[i].sample_count_;
+//  unsigned int sample_duration = stts->table_[i].sample_duration_;
+    samples += sample_count;
+  }
+
+  return samples;
+}
+
+extern struct stss_t* stss_init()
+{
+  stss_t* atom = (stss_t*)malloc(sizeof(stss_t));
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entries_ = 0;
+  atom->sample_numbers_ = 0;
+
+  return atom;
+}
+
+extern void stss_exit(struct stss_t* atom)
+{
+  if(atom->sample_numbers_)
+  {
+    free(atom->sample_numbers_);
+  }
+  free(atom);
+}
+
+extern unsigned int stss_get_nearest_keyframe(struct stss_t const* stss,
+                                              unsigned int sample)
+{
+  // scan the sync samples to find the key frame that precedes the sample number
+  unsigned int i;
+  unsigned int table_sample = 0;
+  for(i = 0; i != stss->entries_; ++i)
+  {
+    table_sample = stss->sample_numbers_[i];
+    if(table_sample >= sample)
+      break;
+  }
+  if(table_sample == sample)
+    return table_sample;
+  else
+    return stss->sample_numbers_[i - 1];
+}
+
+extern stsc_t* stsc_init()
+{
+  stsc_t* atom = (stsc_t*)malloc(sizeof(stsc_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entries_ = 0;
+  atom->table_ = 0;
+
+  return atom;
+}
+
+extern void stsc_exit(struct stsc_t* atom)
+{
+  if(atom->table_)
+  {
+    free(atom->table_);
+  }
+  free(atom);
+}
+
+extern stsz_t* stsz_init()
+{
+  stsz_t* atom = (stsz_t*)malloc(sizeof(stsz_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->sample_size_ = 0;
+  atom->entries_ = 0;
+  atom->sample_sizes_ = 0;
+
+  return atom;
+}
+
+extern void stsz_exit(struct stsz_t* atom)
+{
+  if(atom->sample_sizes_)
+  {
+    free(atom->sample_sizes_);
+  }
+  free(atom);
+}
+
+extern stco_t* stco_init()
+{
+  stco_t* atom = (stco_t*)malloc(sizeof(stco_t));
+
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entries_ = 0;
+  atom->chunk_offsets_ = 0;
+
+  return atom;
+}
+
+extern void stco_exit(stco_t* atom)
+{
+  if(atom->chunk_offsets_)
+  {
+    free(atom->chunk_offsets_);
+  }
+  free(atom);
+}
+
+#if 0
+extern void stco_shift_offsets(stco_t* stco, int offset)
+{
+  unsigned int i;
+  for(i = 0; i != stco->entries_; ++i)
+    stco->chunk_offsets_[i] += offset;
+}
+#endif
+
+extern struct ctts_t* ctts_init()
+{
+  struct ctts_t* atom = (struct ctts_t*)malloc(sizeof(struct ctts_t));
+  atom->version_ = 0;
+  atom->flags_ = 0;
+  atom->entries_ = 0;
+  atom->table_ = 0;
+
+  return atom;
+}
+
+extern void ctts_exit(struct ctts_t* atom)
+{
+  if(atom->table_)
+  {
+    free(atom->table_);
+  }
+  free(atom);
+}
+
+extern unsigned int ctts_get_samples(struct ctts_t const* ctts)
+{
+  unsigned int samples = 0;
+  unsigned int entries = ctts->entries_;
+  unsigned int i;
+  for(i = 0; i != entries; ++i)
+  {
+    unsigned int sample_count = ctts->table_[i].sample_count_;
+//  unsigned int sample_offset = ctts->table_[i].sample_offset_;
+    samples += sample_count;
+  }
+
+  return samples;
+}
+
+extern uint64_t moov_time_to_trak_time(uint64_t t, long moov_time_scale,
+                                       long trak_time_scale)
+{
+  return t * (uint64_t)trak_time_scale / moov_time_scale;
+}
+
+extern uint64_t trak_time_to_moov_time(uint64_t t, long moov_time_scale,
+                                       long trak_time_scale)
+{
+  return t * (uint64_t)moov_time_scale / trak_time_scale;
+}
+
+extern mvex_t* mvex_init()
+{
+  mvex_t* mvex = (mvex_t*)malloc(sizeof(mvex_t));
+  mvex->unknown_atoms_ = 0;
+  mvex->tracks_ = 0;
+
+  return mvex;
+}
+
+extern void mvex_exit(mvex_t* atom)
+{
+  unsigned int i;
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  for(i = 0; i != atom->tracks_; ++i)
+  {
+    trex_exit(atom->trexs_[i]);
+  }
+  free(atom);
+}
+
+extern trex_t* trex_init()
+{
+  trex_t* trex = (trex_t*)malloc(sizeof(trex_t));
+
+  trex->version_ = 0;
+  trex->flags_ = 0;
+  trex->track_id_ = 0;
+  trex->default_sample_description_index_ = 0;
+  trex->default_sample_duration_ = 0;
+  trex->default_sample_size_ = 0;
+  trex->default_sample_flags_ = 0;
+
+  return trex;
+}
+
+extern void trex_exit(trex_t* atom)
+{
+  free(atom);
+}
+
+extern moof_t* moof_init()
+{
+  struct moof_t* moof = (struct moof_t*)malloc(sizeof(struct moof_t));
+  moof->unknown_atoms_ = 0;
+  moof->mfhd_ = 0;
+  moof->tracks_ = 0;
+
+  return moof;
+}
+
+extern void moof_exit(struct moof_t* atom)
+{
+  unsigned int i;
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  if(atom->mfhd_)
+  {
+    mfhd_exit(atom->mfhd_);
+  }
+  for(i = 0; i != atom->tracks_; ++i)
+  {
+    traf_exit(atom->trafs_[i]);
+  }
+  free(atom);
+}
+
+extern mfhd_t* mfhd_init()
+{
+  mfhd_t* mfhd = (mfhd_t*)malloc(sizeof(mfhd_t));
+  mfhd->version_ = 0;
+  mfhd->flags_ = 0;
+  mfhd->sequence_number_ = 0;
+
+  return mfhd;
+}
+
+extern void mfhd_exit(mfhd_t* atom)
+{
+  free(atom);
+}
+
+extern traf_t* traf_init()
+{
+  traf_t* traf = (traf_t*)malloc(sizeof(traf_t));
+  traf->unknown_atoms_ = 0;
+  traf->tfhd_ = 0;
+  traf->trun_ = 0;
+  traf->uuid0_ = 0;
+  traf->uuid1_ = 0;
+
+  return traf;
+}
+
+extern void traf_exit(traf_t* atom)
+{
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  if(atom->tfhd_)
+  {
+    tfhd_exit(atom->tfhd_);
+  }
+  if(atom->trun_)
+  {
+    trun_t* trun = atom->trun_;
+    while(trun)
+    {
+      trun_t* next = trun->next_;
+      trun_exit(trun);
+      trun = next;
+    }
+  }
+  if(atom->uuid0_)
+  {
+    uuid0_exit(atom->uuid0_);
+  }
+  if(atom->uuid1_)
+  {
+    uuid1_exit(atom->uuid1_);
+  }
+  free(atom);
+}
+
+extern tfhd_t* tfhd_init()
+{
+  tfhd_t* tfhd = (tfhd_t*)malloc(sizeof(tfhd_t));
+
+  tfhd->version_ = 0;
+  tfhd->flags_ = 0;
+
+  return tfhd;
+}
+
+extern void tfhd_exit(tfhd_t* atom)
+{
+  free(atom);
+}
+
+extern tfra_t* tfra_init()
+{
+  tfra_t* tfra = (tfra_t*)malloc(sizeof(tfra_t));
+  tfra->table_ = 0;
+
+  return tfra;
+}
+
+extern void tfra_exit(tfra_t* tfra)
+{
+  if(tfra->table_)
+  {
+    free(tfra->table_);
+  }
+  free(tfra);
+}
+
+extern void tfra_add(tfra_t* tfra, tfra_table_t const* table)
+{
+  tfra_table_t* tfra_table;
+
+  // allocate one more entry
+  tfra->table_ = (tfra_table_t*)
+    realloc(tfra->table_, (tfra->number_of_entry_ + 1) * sizeof(tfra_table_t));
+
+  tfra_table = &tfra->table_[tfra->number_of_entry_];
+
+  tfra_table->time_ = table->time_;
+  tfra_table->moof_offset_ = table->moof_offset_;
+  tfra_table->traf_number_ = table->traf_number_;
+  tfra_table->trun_number_ = table->trun_number_;
+  tfra_table->sample_number_ = table->sample_number_;
+  ++tfra->number_of_entry_;
+}
+
+extern mfra_t* mfra_init()
+{
+  mfra_t* mfra = (mfra_t*)malloc(sizeof(mfra_t));
+  mfra->unknown_atoms_ = 0;
+  mfra->tracks_ = 0;
+
+  return mfra;
+}
+
+extern void mfra_exit(mfra_t* atom)
+{
+  unsigned int i;
+  if(atom->unknown_atoms_)
+  {
+    unknown_atom_exit(atom->unknown_atoms_);
+  }
+  for(i = 0; i != atom->tracks_; ++i)
+  {
+    tfra_exit(atom->tfras_[i]);
+  }
+  free(atom);
+}
+
+extern tfra_t const* mfra_get_track(mfra_t const* mfra, unsigned int track_id)
+{
+  unsigned int i;
+
+  for(i = 0; i != mfra->tracks_; ++i)
+  {
+    tfra_t* tfra = mfra->tfras_[i];
+    if(tfra->track_id_ == track_id)
+    {
+      return tfra;
+    }
+  }
+
+  return NULL;
+}
+
+extern trun_t* trun_init()
+{
+  trun_t* trun = (trun_t*)malloc(sizeof(trun_t));
+  trun->version_ = 0;
+  trun->flags_ = 0;
+  trun->sample_count_ = 0;
+  trun->data_offset_ = 0;
+  trun->first_sample_flags_ = 0;
+  trun->table_ = 0;
+  trun->next_ = 0;
+
+  return trun;
+}
+
+extern void trun_exit(struct trun_t* atom)
+{
+  if(atom->table_)
+  {
+    free(atom->table_);
+  }
+  free(atom);
+}
+
+extern uuid0_t* uuid0_init()
+{
+  uuid0_t* uuid = (uuid0_t*)malloc(sizeof(uuid0_t));
+
+  uuid->pts_ = 0;
+  uuid->duration_ = 0;
+
+  return uuid;
+}
+
+extern void uuid0_exit(uuid0_t* atom)
+{
+  free(atom);
+}
+
+extern uuid1_t* uuid1_init()
+{
+  unsigned int i;
+  uuid1_t* uuid = (uuid1_t*)malloc(sizeof(uuid1_t));
+  uuid->entries_ = 0;
+  for(i = 0; i != 2; ++i)
+  {
+    uuid->pts_[i] = 0;
+    uuid->duration_[i] = 0;
+  }
+
+  return uuid;
+}
+
+extern void uuid1_exit(uuid1_t* atom)
+{
+  free(atom);
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_io.h ./src/mp4_io.h
--- ../lighttpd-1.4.26.orig/src/mp4_io.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_io.h	2010-06-03 15:36:00.869343325 +0200
@@ -0,0 +1,836 @@
+/*******************************************************************************
+ mp4_io.h - A library for general MPEG4 I/O.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef MP4_IO_H_AKW
+#define MP4_IO_H_AKW
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef UNUSED
+#elif defined(__GNUC__)
+# define UNUSED(x) UNUSED_ ## x __attribute__((unused))
+#elif defined(__LCLINT__)
+# define UNUSED(x) /*@unused@*/ x
+#else
+# define UNUSED(x) x
+#endif
+
+#ifdef WIN32
+#define ftello _ftelli64
+#define fseeko _fseeki64
+// #define strdup _strdup
+#endif
+
+#define ATOM_PREAMBLE_SIZE 8
+
+#define MAX_TRACKS 8
+
+#define FOURCC(a, b, c, d) ((uint32_t)(a) << 24) + \
+                           ((uint32_t)(b) << 16) + \
+                           ((uint32_t)(c) << 8) + \
+                           ((uint32_t)(d))
+
+#define MP4_INFO(fmt, ...) \
+  if(mp4_context->verbose_ > 2) \
+  { \
+    mp4_log_trace("%s.%d: (info) "fmt, remove_path(__FILE__), __LINE__, __VA_ARGS__); \
+  }
+
+#define MP4_WARNING(fmt, ...) \
+  if(mp4_context->verbose_ > 1) \
+  { \
+    mp4_log_trace("%s.%d: (warning) "fmt, remove_path(__FILE__), __LINE__, __VA_ARGS__); \
+  }
+
+#define MP4_ERROR(fmt, ...) \
+  if(mp4_context->verbose_ > 0) \
+  { \
+    mp4_log_trace("%s.%d: (error) "fmt, remove_path(__FILE__), __LINE__, __VA_ARGS__); \
+  }
+
+MOD_STREAMING_DLL_LOCAL extern uint64_t atoi64(const char* val);
+
+MOD_STREAMING_DLL_LOCAL extern const char* remove_path(const char *path);
+MOD_STREAMING_DLL_LOCAL extern void mp4_log_trace(const char* fmt, ...);
+
+MOD_STREAMING_DLL_LOCAL extern unsigned int read_8(unsigned char const* buffer);
+MOD_STREAMING_DLL_LOCAL extern unsigned char* write_8(unsigned char* buffer, unsigned int v);
+MOD_STREAMING_DLL_LOCAL extern uint16_t read_16(unsigned char const* buffer);
+MOD_STREAMING_DLL_LOCAL extern unsigned char* write_16(unsigned char* buffer, unsigned int v);
+MOD_STREAMING_DLL_LOCAL extern unsigned int read_24(unsigned char const* buffer);
+MOD_STREAMING_DLL_LOCAL extern unsigned char* write_24(unsigned char* buffer, unsigned int v);
+MOD_STREAMING_DLL_LOCAL extern uint32_t read_32(unsigned char const* buffer);
+MOD_STREAMING_DLL_LOCAL extern unsigned char* write_32(unsigned char* buffer, uint32_t v);
+MOD_STREAMING_DLL_LOCAL extern uint64_t read_64(unsigned char const* buffer);
+MOD_STREAMING_DLL_LOCAL extern unsigned char* write_64(unsigned char* buffer, uint64_t v);
+MOD_STREAMING_DLL_LOCAL extern uint32_t read_n(unsigned char const* buffer, unsigned int n);
+MOD_STREAMING_DLL_LOCAL extern unsigned char* write_n(unsigned char* buffer, unsigned int n, uint32_t v);
+
+struct mem_range_t
+{
+  int read_only_;
+  uint64_t filesize_;
+  int fd_;
+
+  // original base mapping
+  void* mmap_addr_;
+  uint64_t mmap_offset_;
+  uint64_t mmap_size_;
+
+#ifdef WIN32
+  void* fileMapHandle_;
+#endif
+};
+typedef struct mem_range_t mem_range_t;
+
+MOD_STREAMING_DLL_LOCAL extern mem_range_t* mem_range_init_read(char const* filename);
+MOD_STREAMING_DLL_LOCAL extern mem_range_t* mem_range_init_write(char const* filename,
+                                  uint64_t offset, uint64_t len);
+MOD_STREAMING_DLL_LOCAL extern void* mem_range_map(mem_range_t* mem_range, uint64_t offset, uint32_t len);
+MOD_STREAMING_DLL_LOCAL extern void mem_range_exit(mem_range_t* mem_range);
+
+struct mp4_atom_t
+{
+  uint32_t type_;
+  uint32_t short_size_;
+  uint64_t size_;
+  uint64_t start_;
+  uint64_t end_;
+};
+typedef struct mp4_atom_t mp4_atom_t;
+
+struct mp4_context_t;
+MOD_STREAMING_DLL_LOCAL extern
+int mp4_atom_read_header(struct mp4_context_t const* mp4_context,
+                         FILE* infile, mp4_atom_t* atom);
+MOD_STREAMING_DLL_LOCAL extern
+int mp4_atom_write_header(unsigned char* outbuffer,
+                          mp4_atom_t const* atom);
+
+struct unknown_atom_t
+{
+  void* atom_;
+  struct unknown_atom_t* next_;
+};
+typedef struct unknown_atom_t unknown_atom_t;
+MOD_STREAMING_DLL_LOCAL extern unknown_atom_t* unknown_atom_init(void);
+MOD_STREAMING_DLL_LOCAL extern void unknown_atom_exit(unknown_atom_t* atom);
+
+struct moov_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct mvhd_t* mvhd_;
+  unsigned int tracks_;
+  struct trak_t* traks_[MAX_TRACKS];
+  struct mvex_t* mvex_;
+
+  int is_indexed_;
+};
+typedef struct moov_t moov_t;
+MOD_STREAMING_DLL_LOCAL extern moov_t* moov_init(void);
+MOD_STREAMING_DLL_LOCAL extern void moov_exit(moov_t* atom);
+MOD_STREAMING_DLL_LOCAL extern struct trak_t* moov_get_track(moov_t* moov, unsigned int track_id);
+
+struct mvhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint64_t creation_time_;      // seconds since midnite, Jan .1 1904 (UTC)
+  uint64_t modification_time_;  // seconds since midnite, Jan .1 1904 (UTC)
+  uint32_t timescale_;          // time units that pass in one second
+  uint64_t duration_;           // duration of the longest track
+  uint32_t rate_;               // preferred playback rate (16.16)
+  uint16_t volume_;             // preferred playback volume (8.8)
+  uint16_t reserved1_;
+  uint32_t reserved2_[2];
+  uint32_t matrix_[9];
+  uint32_t predefined_[6];
+  uint32_t next_track_id_;
+};
+typedef struct mvhd_t mvhd_t;
+MOD_STREAMING_DLL_LOCAL extern mvhd_t* mvhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern mvhd_t* mvhd_copy(mvhd_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void mvhd_exit(mvhd_t* atom);
+
+struct trak_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct tkhd_t* tkhd_;
+  struct mdia_t* mdia_;
+  struct edts_t* edts_;
+
+  unsigned int chunks_size_;
+  struct chunks_t* chunks_;
+
+  unsigned int samples_size_;
+  struct samples_t* samples_;
+
+  // current pts when reading fragments
+//  uint64_t fragment_pts_;
+};
+typedef struct trak_t trak_t;
+MOD_STREAMING_DLL_LOCAL extern trak_t* trak_init(void);
+MOD_STREAMING_DLL_LOCAL extern unsigned int trak_bitrate(trak_t const* trak);
+MOD_STREAMING_DLL_LOCAL extern void trak_exit(trak_t* trak);
+
+struct tkhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint64_t creation_time_;      // seconds since midnite, Jan .1 1904 (UTC)
+  uint64_t modification_time_;  // seconds since midnite, Jan .1 1904 (UTC)
+  uint32_t track_id_;
+  uint32_t reserved_;
+  uint64_t duration_;           // duration of this track (mvhd.timescale)
+  uint32_t reserved2_[2];
+  uint16_t layer_;              // front-to-back ordering
+  uint16_t predefined_;
+  uint16_t volume_;             // relative audio volume (8.8)
+  uint16_t reserved3_;
+  uint32_t matrix_[9];          // transformation matrix
+  uint32_t width_;              // visual presentation width (16.16)
+  uint32_t height_;             // visual presentation height (16.16)
+};
+typedef struct tkhd_t tkhd_t;
+MOD_STREAMING_DLL_LOCAL extern tkhd_t* tkhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern tkhd_t* tkhd_copy(tkhd_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void tkhd_exit(tkhd_t* tkhd);
+
+struct mdia_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct mdhd_t* mdhd_;
+  struct hdlr_t* hdlr_;
+  struct minf_t* minf_;
+};
+typedef struct mdia_t mdia_t;
+MOD_STREAMING_DLL_LOCAL extern mdia_t* mdia_init(void);
+MOD_STREAMING_DLL_LOCAL extern void mdia_exit(mdia_t* atom);
+
+struct elst_table_t
+{
+  uint64_t segment_duration_;
+  int64_t media_time_;
+  int16_t media_rate_integer_;
+  int16_t media_rate_fraction_;
+};
+typedef struct elst_table_t elst_table_t;
+
+struct elst_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entry_count_;
+  struct elst_table_t* table_;
+};
+typedef struct elst_t elst_t;
+MOD_STREAMING_DLL_LOCAL extern elst_t* elst_init(void);
+MOD_STREAMING_DLL_LOCAL extern void elst_exit(elst_t* atom);
+
+struct edts_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct elst_t* elst_;
+};
+typedef struct edts_t edts_t;
+MOD_STREAMING_DLL_LOCAL extern edts_t* edts_init(void);
+MOD_STREAMING_DLL_LOCAL extern void edts_exit(edts_t* atom);
+
+struct mdhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint64_t creation_time_;      // seconds since midnite, Jan .1 1904 (UTC)
+  uint64_t modification_time_;  // seconds since midnite, Jan .1 1904 (UTC)
+  uint32_t timescale_;          // time units that pass in one second
+  uint64_t duration_;           // duration of this media
+  unsigned int language_[3];    // language code for this media (ISO 639-2/T)
+  uint16_t predefined_;
+};
+typedef struct mdhd_t mdhd_t;
+MOD_STREAMING_DLL_LOCAL extern struct mdhd_t* mdhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern mdhd_t* mdhd_copy(mdhd_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void mdhd_exit(struct mdhd_t* mdhd);
+
+struct hdlr_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t predefined_;
+  uint32_t handler_type_;       // format of the contents ('vide', 'soun', ...)
+  uint32_t reserved1_;
+  uint32_t reserved2_;
+  uint32_t reserved3_;
+  char* name_;                  // human-readable name for the track type (UTF8)
+};
+typedef struct hdlr_t hdlr_t;
+MOD_STREAMING_DLL_LOCAL extern hdlr_t* hdlr_init(void);
+MOD_STREAMING_DLL_LOCAL extern hdlr_t* hdlr_copy(hdlr_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void hdlr_exit(hdlr_t* atom);
+
+struct minf_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct vmhd_t* vmhd_;
+  struct smhd_t* smhd_;
+  struct dinf_t* dinf_;
+  struct stbl_t* stbl_;
+};
+typedef struct minf_t minf_t;
+MOD_STREAMING_DLL_LOCAL extern minf_t* minf_init(void);
+MOD_STREAMING_DLL_LOCAL extern void minf_exit(minf_t* atom);
+
+struct vmhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint16_t graphics_mode_;      // composition mode (0=copy)
+  uint16_t opcolor_[3];
+};
+typedef struct vmhd_t vmhd_t;
+MOD_STREAMING_DLL_LOCAL extern vmhd_t* vmhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern vmhd_t* vmhd_copy(vmhd_t* rhs);
+MOD_STREAMING_DLL_LOCAL extern void vmhd_exit(vmhd_t* atom);
+
+struct smhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint16_t balance_;            // place mono audio tracks in stereo space (8.8)
+  uint16_t reserved_;
+};
+typedef struct smhd_t smhd_t;
+MOD_STREAMING_DLL_LOCAL extern smhd_t* smhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern smhd_t* smhd_copy(smhd_t* rhs);
+MOD_STREAMING_DLL_LOCAL extern void smhd_exit(smhd_t* atom);
+
+struct dinf_t
+{
+  struct dref_t* dref_;         // declares the location of the media info
+};
+typedef struct dinf_t dinf_t;
+MOD_STREAMING_DLL_LOCAL extern dinf_t* dinf_init(void);
+MOD_STREAMING_DLL_LOCAL extern dinf_t* dinf_copy(dinf_t* rhs);
+MOD_STREAMING_DLL_LOCAL extern void dinf_exit(dinf_t* atom);
+
+struct dref_table_t
+{
+  unsigned int flags_;          // 0x000001 is self contained
+  char* name_;                  // name is a URN
+  char* location_;              // location is a URL
+};
+typedef struct dref_table_t dref_table_t;
+MOD_STREAMING_DLL_LOCAL extern void dref_table_init(dref_table_t* entry);
+MOD_STREAMING_DLL_LOCAL extern void dref_table_assign(dref_table_t* lhs, dref_table_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void dref_table_exit(dref_table_t* entry);
+
+struct dref_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  unsigned int entry_count_;
+  dref_table_t* table_;
+};
+typedef struct dref_t dref_t;
+MOD_STREAMING_DLL_LOCAL extern dref_t* dref_init(void);
+MOD_STREAMING_DLL_LOCAL extern dref_t* dref_copy(dref_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void dref_exit(dref_t* atom);
+
+struct stbl_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct stsd_t* stsd_;         // sample description
+  struct stts_t* stts_;         // decoding time-to-sample
+  struct stss_t* stss_;         // sync sample
+  struct stsc_t* stsc_;         // sample-to-chunk
+  struct stsz_t* stsz_;         // sample size
+  struct stco_t* stco_;         // chunk offset
+  struct ctts_t* ctts_;         // composition time-to-sample
+};
+typedef struct stbl_t stbl_t;
+MOD_STREAMING_DLL_LOCAL extern stbl_t* stbl_init(void);
+MOD_STREAMING_DLL_LOCAL extern void stbl_exit(stbl_t* atom);
+MOD_STREAMING_DLL_LOCAL extern
+unsigned int stbl_get_nearest_keyframe(stbl_t const* stbl, unsigned int sample);
+
+struct stsd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entries_;
+  struct sample_entry_t* sample_entries_;
+};
+typedef struct stsd_t stsd_t;
+MOD_STREAMING_DLL_LOCAL extern stsd_t* stsd_init(void);
+MOD_STREAMING_DLL_LOCAL extern stsd_t* stsd_copy(stsd_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern void stsd_exit(stsd_t* atom);
+
+struct video_sample_entry_t
+{
+  uint16_t version_;
+  uint16_t revision_level_;
+  uint32_t vendor_;
+  uint32_t temporal_quality_;
+  uint32_t spatial_quality_;
+  uint16_t width_;
+  uint16_t height_;
+  uint32_t horiz_resolution_;   // pixels per inch (16.16)
+  uint32_t vert_resolution_;    // pixels per inch (16.16)
+  uint32_t data_size_;
+  uint16_t frame_count_;        // number of frames in each sample
+  uint8_t compressor_name_[32]; // informative purposes (pascal string)
+  uint16_t depth_;              // images are in colour with no alpha (24)
+  int16_t color_table_id_;
+};
+typedef struct video_sample_entry_t video_sample_entry_t;
+MOD_STREAMING_DLL_LOCAL extern video_sample_entry_t* video_sample_entry_init(void);
+
+struct audio_sample_entry_t
+{
+  uint16_t version_;
+  uint16_t revision_;
+  uint32_t vendor_;
+  uint16_t channel_count_;      // mono(1), stereo(2)
+  uint16_t sample_size_;        // (bits)
+  uint16_t compression_id_;
+  uint16_t packet_size_;
+  uint32_t samplerate_;         // sampling rate (16.16)
+};
+typedef struct audio_sample_entry_t audio_sample_entry_t;
+MOD_STREAMING_DLL_LOCAL extern audio_sample_entry_t* audio_sample_entry_init(void);
+
+enum h264_profile_t
+{
+  H264_PROFILE_BASELINE = 66,
+  H264_PROFILE_MAIN = 77,
+  H264_PROFILE_EXTENDED = 88,
+  H264_PROFILE_HIGH = 100,
+  H264_PROFILE_HIGH10 = 110,
+  H264_PROFILE_HIGH422 = 122,
+  H264_PROFILE_HIGH444 = 144,
+  H264_PROFILE_HIGH444_PREDICTIVE = 244
+};
+typedef enum h264_profile_t h264_profile_t;
+
+struct sample_entry_t
+{
+  unsigned int len_;
+  uint32_t fourcc_;
+  unsigned char* buf_;
+
+  struct video_sample_entry_t* video_;
+  struct audio_sample_entry_t* audio_;
+//struct hint_sample_entry_t* hint_;
+
+  unsigned int codec_private_data_length_;
+  unsigned char const* codec_private_data_;
+
+  // avcC
+  unsigned int nal_unit_length_;
+  unsigned int sps_length_;
+  unsigned char* sps_;
+  unsigned int pps_length_;
+  unsigned char* pps_;
+
+  // sound (WAVEFORMATEX) structure
+  uint16_t wFormatTag;
+  uint16_t nChannels;
+  uint32_t nSamplesPerSec;
+  uint32_t nAvgBytesPerSec;
+  uint16_t nBlockAlign;
+  uint16_t wBitsPerSample;
+
+  unsigned int samplerate_hi_;
+  unsigned int samplerate_lo_;
+
+  // esds
+  unsigned char object_type_id_;
+  unsigned int max_bitrate_;
+  unsigned int avg_bitrate_;
+};
+typedef struct sample_entry_t sample_entry_t;
+MOD_STREAMING_DLL_LOCAL extern
+void sample_entry_init(sample_entry_t* sample_entry);
+MOD_STREAMING_DLL_LOCAL extern
+void sample_entry_assign(sample_entry_t* lhs, sample_entry_t const* rhs);
+MOD_STREAMING_DLL_LOCAL extern
+void sample_entry_exit(sample_entry_t* sample_entry);
+MOD_STREAMING_DLL_LOCAL extern
+void sample_entry_get_adts(sample_entry_t const* sample_entry,
+                           unsigned int sample_size, uint8_t* buf);
+
+struct stts_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entries_;
+  struct stts_table_t* table_;
+};
+typedef struct stts_t stts_t;
+MOD_STREAMING_DLL_LOCAL extern stts_t* stts_init(void);
+MOD_STREAMING_DLL_LOCAL extern void stts_exit(stts_t* atom);
+MOD_STREAMING_DLL_LOCAL extern unsigned int stts_get_sample(stts_t const* stts, uint64_t time);
+MOD_STREAMING_DLL_LOCAL extern uint64_t stts_get_time(stts_t const* stts, unsigned int sample);
+MOD_STREAMING_DLL_LOCAL extern uint64_t stts_get_duration(stts_t const* stts);
+MOD_STREAMING_DLL_LOCAL extern unsigned int stts_get_samples(stts_t const* stts);
+
+struct stts_table_t
+{
+  uint32_t sample_count_;
+  uint32_t sample_duration_;
+};
+typedef struct stts_table_t stts_table_t;
+
+struct stss_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entries_;
+  uint32_t* sample_numbers_;
+};
+typedef struct stss_t stss_t;
+MOD_STREAMING_DLL_LOCAL extern stss_t* stss_init(void);
+MOD_STREAMING_DLL_LOCAL extern void stss_exit(stss_t* atom);
+MOD_STREAMING_DLL_LOCAL extern
+unsigned int stss_get_nearest_keyframe(stss_t const* stss, unsigned int sample);
+
+struct stsc_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entries_;
+  struct stsc_table_t* table_;
+};
+typedef struct stsc_t stsc_t;
+MOD_STREAMING_DLL_LOCAL extern stsc_t* stsc_init(void);
+MOD_STREAMING_DLL_LOCAL extern void stsc_exit(stsc_t* atom);
+
+struct stsc_table_t
+{
+  uint32_t chunk_;
+  uint32_t samples_;
+  uint32_t id_;
+};
+typedef struct stsc_table_t stsc_table_t;
+
+struct stsz_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t sample_size_;
+  uint32_t entries_;
+  uint32_t* sample_sizes_;
+};
+typedef struct stsz_t stsz_t;
+MOD_STREAMING_DLL_LOCAL extern stsz_t* stsz_init(void);
+MOD_STREAMING_DLL_LOCAL extern void stsz_exit(stsz_t* atom);
+
+struct stco_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entries_;
+  uint64_t* chunk_offsets_;
+
+  void* stco_inplace_;          // newly generated stco (patched inplace)
+};
+typedef struct stco_t stco_t;
+MOD_STREAMING_DLL_LOCAL extern stco_t* stco_init(void);
+MOD_STREAMING_DLL_LOCAL extern void stco_exit(stco_t* atom);
+
+struct ctts_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t entries_;
+  struct ctts_table_t* table_;
+};
+typedef struct ctts_t ctts_t;
+MOD_STREAMING_DLL_LOCAL extern ctts_t* ctts_init(void);
+MOD_STREAMING_DLL_LOCAL extern void ctts_exit(ctts_t* atom);
+MOD_STREAMING_DLL_LOCAL extern unsigned int ctts_get_samples(ctts_t const* ctts);
+
+struct ctts_table_t
+{
+  uint32_t sample_count_;
+  uint32_t sample_offset_;
+};
+typedef struct ctts_table_t ctts_table_t;
+
+struct samples_t
+{
+  uint64_t pts_;                // decoding/presentation time
+  unsigned int size_;           // size in bytes
+  uint64_t pos_;                // byte offset
+  unsigned int cto_;            // composition time offset
+
+  unsigned int is_ss_:1;        // sync sample
+  unsigned int is_smooth_ss_:1; // sync sample for smooth streaming
+};
+typedef struct samples_t samples_t;
+
+struct chunks_t
+{
+  unsigned int sample_;         // number of the first sample in the chunk
+  unsigned int size_;           // number of samples in the chunk
+  int id_;                      // not used
+  uint64_t pos_;                // start byte position of chunk
+};
+typedef struct chunks_t chunks_t;
+
+MOD_STREAMING_DLL_LOCAL extern
+uint64_t moov_time_to_trak_time(uint64_t t, long moov_time_scale,
+                                long trak_time_scale);
+MOD_STREAMING_DLL_LOCAL extern
+uint64_t trak_time_to_moov_time(uint64_t t, long moov_time_scale,
+                                long trak_time_scale);
+
+struct mvex_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  unsigned int tracks_;
+  struct trex_t* trexs_[MAX_TRACKS];
+};
+typedef struct mvex_t mvex_t;
+MOD_STREAMING_DLL_LOCAL extern mvex_t* mvex_init(void);
+MOD_STREAMING_DLL_LOCAL extern void mvex_exit(mvex_t* mvex);
+
+struct trex_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t track_id_;
+  uint32_t default_sample_description_index_;
+  uint32_t default_sample_duration_;
+  uint32_t default_sample_size_;
+  uint32_t default_sample_flags_;
+};
+typedef struct trex_t trex_t;
+MOD_STREAMING_DLL_LOCAL extern trex_t* trex_init(void);
+MOD_STREAMING_DLL_LOCAL extern void trex_exit(trex_t* trex);
+
+struct moof_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct mfhd_t* mfhd_;
+  unsigned int tracks_;
+  struct traf_t* trafs_[MAX_TRACKS];
+};
+typedef struct moof_t moof_t;
+MOD_STREAMING_DLL_LOCAL extern moof_t* moof_init(void);
+MOD_STREAMING_DLL_LOCAL extern void moof_exit(moof_t* atom);
+
+struct mfhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  // the ordinal number of this fragment, in increasing order
+  uint32_t sequence_number_;
+};
+typedef struct mfhd_t mfhd_t;
+MOD_STREAMING_DLL_LOCAL extern mfhd_t* mfhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern void mfhd_exit(mfhd_t* atom);
+
+struct traf_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  struct tfhd_t* tfhd_;
+  struct trun_t* trun_;
+  struct uuid0_t* uuid0_;
+  struct uuid1_t* uuid1_;
+};
+typedef struct traf_t traf_t;
+MOD_STREAMING_DLL_LOCAL extern traf_t* traf_init(void);
+MOD_STREAMING_DLL_LOCAL extern void traf_exit(traf_t* atom);
+
+struct tfhd_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t track_id_;
+  // all the following are optional fields
+  uint64_t base_data_offset_;
+  uint32_t sample_description_index_;
+  uint32_t default_sample_duration_;
+  uint32_t default_sample_size_;
+  uint32_t default_sample_flags_;
+};
+typedef struct tfhd_t tfhd_t;
+MOD_STREAMING_DLL_LOCAL extern tfhd_t* tfhd_init(void);
+MOD_STREAMING_DLL_LOCAL extern void tfhd_exit(tfhd_t* atom);
+
+struct tfra_table_t
+{
+  uint64_t time_;
+  uint64_t moof_offset_;
+  uint32_t traf_number_;
+  uint32_t trun_number_;
+  uint32_t sample_number_;
+};
+typedef struct tfra_table_t tfra_table_t;
+
+struct tfra_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  uint32_t track_id_;
+  unsigned int length_size_of_traf_num_;
+  unsigned int length_size_of_trun_num_;
+  unsigned int length_size_of_sample_num_;
+  uint32_t number_of_entry_;
+  struct tfra_table_t* table_;
+};
+typedef struct tfra_t tfra_t;
+MOD_STREAMING_DLL_LOCAL extern tfra_t* tfra_init(void);
+MOD_STREAMING_DLL_LOCAL extern void tfra_exit(tfra_t* tfra);
+MOD_STREAMING_DLL_LOCAL extern void tfra_add(tfra_t* tfra, tfra_table_t const* table);
+
+struct mfra_t
+{
+  struct unknown_atom_t* unknown_atoms_;
+  unsigned int tracks_;
+  struct tfra_t* tfras_[MAX_TRACKS];
+};
+typedef struct mfra_t mfra_t;
+MOD_STREAMING_DLL_LOCAL extern mfra_t* mfra_init(void);
+MOD_STREAMING_DLL_LOCAL extern void mfra_exit(mfra_t* atom);
+MOD_STREAMING_DLL_LOCAL extern tfra_t const* mfra_get_track(mfra_t const* mfra, unsigned int track_id);
+
+struct trun_table_t
+{
+  uint32_t sample_duration_;
+  uint32_t sample_size_;
+  uint32_t sample_flags_;
+  uint32_t sample_composition_time_offset_;
+};
+typedef struct trun_table_t trun_table_t;
+
+struct trun_t
+{
+  unsigned int version_;
+  unsigned int flags_;
+  // the number of samples being added in this fragment; also the number of rows
+  // in the following table (the rows can be empty)
+  uint32_t sample_count_;
+  // is added to the implicit or explicit data_offset established in the track
+  // fragment header
+  int32_t data_offset_;
+  // provides a set of flags for the first sample only of this run
+  uint32_t first_sample_flags_;
+
+  trun_table_t* table_;
+
+  // additional info for uuid
+//  trak_t const* trak_;
+//  unsigned int start_;
+  struct trun_t* next_;
+};
+typedef struct trun_t trun_t;
+MOD_STREAMING_DLL_LOCAL extern struct trun_t* trun_init(void);
+MOD_STREAMING_DLL_LOCAL extern void trun_exit(struct trun_t* atom);
+
+struct uuid0_t
+{
+  uint64_t pts_;
+  uint64_t duration_;
+};
+typedef struct uuid0_t uuid0_t;
+MOD_STREAMING_DLL_LOCAL extern uuid0_t* uuid0_init(void);
+MOD_STREAMING_DLL_LOCAL extern void uuid0_exit(uuid0_t* atom);
+
+struct uuid1_t
+{
+  unsigned int entries_;
+  uint64_t pts_[2];
+  uint64_t duration_[2];
+};
+typedef struct uuid1_t uuid1_t;
+MOD_STREAMING_DLL_LOCAL extern uuid1_t* uuid1_init(void);
+MOD_STREAMING_DLL_LOCAL extern void uuid1_exit(uuid1_t* atom);
+
+// random access structure similar to mfra, but with size field
+struct rxs_t
+{
+  uint64_t time_;
+  uint64_t offset_;
+  uint64_t size_;
+};
+typedef struct rxs_t rxs_t;
+
+#define MP4_ELEMENTARY_STREAM_DESCRIPTOR_TAG   3
+#define MP4_DECODER_CONFIG_DESCRIPTOR_TAG      4
+#define MP4_DECODER_SPECIFIC_DESCRIPTOR_TAG    5
+
+#define MP4_MPEG4Audio                      0x40
+#define MP4_MPEG2AudioMain                  0x66
+#define MP4_MPEG2AudioLowComplexity         0x67
+#define MP4_MPEG2AudioScaleableSamplingRate 0x68
+#define MP4_MPEG2AudioPart3                 0x69
+#define MP4_MPEG1Audio                      0x6b
+
+struct mp4_context_t
+{
+  char* filename_;
+  FILE* infile;
+
+  int verbose_;
+
+  // the atoms as found in the stream
+  mp4_atom_t ftyp_atom;
+  mp4_atom_t moov_atom;
+  mp4_atom_t mdat_atom;
+  mp4_atom_t mfra_atom;
+
+  // the actual binary data
+  unsigned char* moov_data;
+  unsigned char* mfra_data;
+
+  // the parsed atoms
+  moov_t* moov;
+
+  // the file offset of a moof atom, used for base_data_offset
+  uint64_t moof_offset_;
+};
+typedef struct mp4_context_t mp4_context_t;
+
+enum mp4_open_flags
+{
+  MP4_OPEN_MOOV = 0x00000001,
+  MP4_OPEN_MOOF = 0x00000002,
+  MP4_OPEN_MDAT = 0x00000004,
+  MP4_OPEN_MFRA = 0x00000008,
+  MP4_OPEN_ALL  = 0x0000000f
+};
+typedef enum mp4_open_flags mp4_open_flags;
+
+MOD_STREAMING_DLL_LOCAL extern
+mp4_context_t* mp4_open(const char* filename, int64_t filesize,
+                        mp4_open_flags flags, int verbose);
+
+MOD_STREAMING_DLL_LOCAL extern void mp4_close(mp4_context_t* mp4_context);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // MP4_IO_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_process.c ./src/mp4_process.c
--- ../lighttpd-1.4.26.orig/src/mp4_process.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_process.c	2010-06-03 15:36:00.870347357 +0200
@@ -0,0 +1,227 @@
+/*******************************************************************************
+ mp4_process.c - .
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define _CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+#endif
+
+#if !defined(BUILDING_NGINX)
+#include "mp4_process.h"
+#endif
+#include "moov.h"
+
+#include "mp4_io.h"
+#include "output_bucket.h"
+
+#if defined(BUILDING_H264_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_mp4.h"
+#endif
+#if defined(BUILDING_MP4SPLIT)
+#include "output_mov.h"
+#endif
+#if defined(BUILDING_SMOOTH_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_ismv.h"
+#endif
+#if defined(BUILDING_FLV_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_flv.h"
+#endif
+#if defined(BUILDING_SMOOTH_STREAMING) || defined(BUILDING_MP4SPLIT)
+#include "output_ts.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef WIN32
+#define snprintf _snprintf
+#endif
+
+static int rxs_get_bucket(char const* filename, bucket_t** buckets,
+                          mp4_split_options_t* options)
+{
+  // fragment request?
+  if(!options->fragments)
+    return 0;
+
+  {
+    char rxs_filename[256];
+    mem_range_t* mem_range;
+    unsigned char const* first;
+    unsigned char const* last;
+
+    uint64_t fragment_start;
+    if(options->audio_fragment_start != UINT64_MAX)
+    {
+      fragment_start = options->audio_fragment_start;
+    }
+    else
+    {
+      fragment_start = options->video_fragment_start;
+    }
+    
+    // create rxs filename
+    snprintf(rxs_filename, sizeof(rxs_filename), "%s.%u.rxs",
+             filename, options->fragment_track_id);
+
+    mem_range = mem_range_init_read(rxs_filename);
+    if(!mem_range)
+    {
+      // TODO: CHANGE BACK TO 0, otherwise VOD won't work
+//    return 409; // 409 Conflict
+      return 0;
+    }
+
+    first = (unsigned char const*)(mem_range_map(mem_range, 0, (uint32_t)mem_range->filesize_));
+    last = first + mem_range->filesize_;
+    while(first != last)
+    {
+      uint64_t time = read_64(first);
+      if(time == fragment_start)
+      {
+        uint64_t offset = read_64(first + 8);
+        uint64_t size = read_64(first + 16);
+        bucket_insert_tail(buckets, bucket_init_file(offset, size));
+        break;
+      }
+      first += sizeof(rxs_t);
+    }
+    mem_range_exit(mem_range);
+
+    return first == last ? 404 : 200;
+  }
+}
+
+#if defined(BUILDING_NGINX)
+static
+#else
+extern
+#endif
+int mp4_process(const char* filename, uint64_t filesize, int verbose,
+                bucket_t** buckets,
+                mp4_split_options_t* options)
+{
+  int result = 1;
+
+  // implement mod_flv_streaming for convenience
+  if(ends_with(filename, ".flv") || options->input_format == INPUT_FORMAT_FLV)
+  {
+    static const unsigned char flv_header[13] = {
+			'F', 'L', 'V', 0x01, 0x01, 0x00, 0x00, 0x00, 0x09,
+      0x00, 0x00, 0x00, 0x09
+    };
+    uint64_t start = options->start_integer;
+    if(start != 0)
+    {
+      bucket_insert_tail(buckets, bucket_init_memory(flv_header, 13));
+    }
+    bucket_insert_tail(buckets, bucket_init_file(start, filesize - start));
+
+    return 200; // HTTP_OK;
+  }
+
+  // check for serving fragments using the fast random access file
+  {
+    int http_status = rxs_get_bucket(filename, buckets, options);
+    if(http_status)
+    {
+      return http_status;
+    }
+  }
+
+#ifdef HAVE_OUTPUT_TS
+  if(options->fragments && options->output_format == OUTPUT_FORMAT_TS)
+  {
+    result = output_ts(filename, buckets, options);
+
+    return result == 0 ? 415 : 200;
+  }
+#endif
+
+  // Open the file
+  {
+    mp4_open_flags flags = options->fragments ? MP4_OPEN_MFRA : MP4_OPEN_ALL;
+    mp4_context_t* mp4_context =
+      mp4_open(filename, filesize, flags, verbose);
+
+    if(mp4_context == NULL)
+    {
+      result = 0;
+    }
+
+    if(result)
+    {
+#ifdef HAVE_OUTPUT_ISMV
+      if(options->fragments)
+      {
+        result = output_ismv(mp4_context, buckets, options);
+      }
+      else
+#endif
+      {
+        // split the movie
+        unsigned int trak_sample_start[MAX_TRACKS];
+        unsigned int trak_sample_end[MAX_TRACKS];
+        result = mp4_split(mp4_context, trak_sample_start, trak_sample_end,
+                           options);
+        if(result)
+        {
+          if(0)
+          {
+          }
+#ifdef HAVE_OUTPUT_FLV
+          else if(options->output_format == OUTPUT_FORMAT_FLV)
+          {
+            result = output_flv(mp4_context,
+                                trak_sample_start,
+                                trak_sample_end,
+                                buckets, options);
+          }
+#endif
+#ifdef HAVE_OUTPUT_MP4
+          else if(options->output_format == OUTPUT_FORMAT_MP4)
+          {
+            result = output_mp4(mp4_context,
+                                trak_sample_start,
+                                trak_sample_end,
+                                buckets, options);
+          }
+#endif
+#ifdef HAVE_OUTPUT_MOV
+          else if(options->output_format == OUTPUT_FORMAT_MOV)
+          {
+            result = output_mov(mp4_context,
+                                trak_sample_start,
+                                trak_sample_end,
+                                buckets, options);
+          }
+#endif
+        }
+      }
+
+      // close the file
+      mp4_close(mp4_context);
+    }
+  }
+
+  if(!result)
+  {
+    return 415; // HTTP_UNSUPPORTED_MEDIA_TYPE;
+  }
+
+  return 200; // HTTP_OK;
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_process.h ./src/mp4_process.h
--- ../lighttpd-1.4.26.orig/src/mp4_process.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_process.h	2010-06-03 15:36:00.871351668 +0200
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ mp4_process.h -
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef MP4_PROCESS_H_AKW
+#define MP4_PROCESS_H_AKW
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct bucket_t;
+struct mp4_split_options_t;
+
+MOD_STREAMING_DLL_LOCAL extern
+int mp4_process(const char* filename, uint64_t filesize, int verbose,
+                struct bucket_t** buckets,
+                struct mp4_split_options_t* options);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // MP4_PROCESS_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_reader.c ./src/mp4_reader.c
--- ../lighttpd-1.4.26.orig/src/mp4_reader.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_reader.c	2010-06-03 15:36:00.877375303 +0200
@@ -0,0 +1,2617 @@
+/*******************************************************************************
+ mp4_reader.c - A library for reading MPEG4.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef __cplusplus
+#define __STDC_FORMAT_MACROS // C++ should define this for PRIu64
+#define __STDC_LIMIT_MACROS  // C++ should define this for UINT64_MAX
+#endif
+
+#include "mp4_reader.h"
+#include "mp4_io.h"
+#include <stdlib.h>
+#include <string.h>
+
+struct atom_t
+{
+ uint32_t type_;
+ uint32_t short_size_;
+ uint64_t size_;
+ unsigned char* start_;
+ unsigned char* end_;
+};
+typedef struct atom_t atom_t;
+
+static void atom_print(mp4_context_t const* mp4_context, atom_t const* atom)
+{
+  MP4_INFO("Atom(%c%c%c%c,%"PRIu64")\n",
+           atom->type_ >> 24,
+           atom->type_ >> 16,
+           atom->type_ >> 8,
+           atom->type_,
+           atom->size_);
+}
+
+static unsigned char*
+atom_read_header(mp4_context_t const* mp4_context, unsigned char* buffer,
+                 atom_t* atom)
+{
+  atom->start_ = buffer;
+  atom->short_size_ = read_32(buffer);
+  atom->type_ = read_32(buffer + 4);
+
+  if(atom->short_size_ == 1)
+    atom->size_ = read_64(buffer + 8);
+  else
+    atom->size_ = atom->short_size_;
+
+  atom->end_ = atom->start_ + atom->size_;
+
+  atom_print(mp4_context, atom);
+
+  if(atom->size_ < ATOM_PREAMBLE_SIZE)
+  {
+    MP4_ERROR("%s", "Error: invalid atom size\n");
+    return 0;
+  }
+
+  return buffer + ATOM_PREAMBLE_SIZE + (atom->short_size_ == 1 ? 8 : 0);
+}
+
+static struct unknown_atom_t* unknown_atom_add_atom(struct unknown_atom_t* parent, void* atom)
+{
+  size_t size = read_32((const unsigned char*)atom);
+  unknown_atom_t* unknown = unknown_atom_init();
+  unknown->atom_ = malloc(size);
+  memcpy(unknown->atom_, atom, size);
+
+  {
+    unknown_atom_t** adder = &parent;
+    while(*adder != NULL)
+    {
+      adder = &(*adder)->next_;
+    }
+    *adder = unknown;
+  }
+
+  return parent;
+}
+
+extern int atom_reader(struct mp4_context_t const* mp4_context,
+                       struct atom_read_list_t* atom_read_list,
+                       unsigned int atom_read_list_size,
+                       void* parent,
+                       unsigned char* buffer, uint64_t size)
+{
+  atom_t leaf_atom;
+  unsigned char* buffer_start = buffer;
+
+  while(buffer < buffer_start + size)
+  {
+    unsigned int i;
+    buffer = atom_read_header(mp4_context, buffer, &leaf_atom);
+
+    if(buffer == NULL)
+    {
+      return 0;
+    }
+
+    for(i = 0; i != atom_read_list_size; ++i)
+    {
+      if(leaf_atom.type_ == atom_read_list[i].type_)
+      {
+        break;
+      }
+    }
+
+    if(i == atom_read_list_size)
+    {
+      // add to unkown chunks
+      (*(unknown_atom_t**)parent) =
+        unknown_atom_add_atom(*(unknown_atom_t**)(parent), buffer - ATOM_PREAMBLE_SIZE);
+    }
+    else
+    {
+      void* child =
+        atom_read_list[i].reader_(mp4_context, parent, buffer,
+          leaf_atom.size_ - ATOM_PREAMBLE_SIZE);
+      if(!child)
+        break;
+      if(!atom_read_list[i].destination_(mp4_context, parent, child))
+        break;
+    }
+    buffer = leaf_atom.end_;
+  }
+
+  if(buffer < buffer_start + size)
+  {
+    return 0;
+  }
+
+  return 1;
+}
+
+static void* ctts_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  ctts_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = ctts_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+
+  if(size < 8 + atom->entries_ * sizeof(ctts_table_t))
+    return 0;
+
+  buffer += 8;
+
+  atom->table_ = (ctts_table_t*)(malloc(atom->entries_ * sizeof(ctts_table_t)));
+
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    atom->table_[i].sample_count_ = read_32(buffer + 0);
+    atom->table_[i].sample_offset_ = read_32(buffer + 4);
+    buffer += 8;
+  }
+
+  return atom;
+}
+
+static void* stco_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stco_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = stco_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+  buffer += 8;
+
+  if(size < 8 + atom->entries_ * sizeof(uint32_t))
+    return 0;
+
+  atom->chunk_offsets_ = (uint64_t*)malloc(atom->entries_ * sizeof(uint64_t));
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    atom->chunk_offsets_[i] = read_32(buffer);
+    buffer += 4;
+  }
+
+  return atom;
+}
+
+static void* co64_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stco_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = stco_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+  buffer += 8;
+
+  if(size < 8 + atom->entries_ * sizeof(uint64_t))
+    return 0;
+
+  atom->chunk_offsets_ = (uint64_t*)malloc(atom->entries_ * sizeof(uint64_t));
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    atom->chunk_offsets_[i] = read_64(buffer);
+    buffer += 8;
+  }
+
+  return atom;
+}
+
+static void* stsz_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stsz_t* atom;
+
+  if(size < 12)
+  {
+    MP4_ERROR("%s", "Error: not enough bytes for stsz atom\n");
+    return 0;
+  }
+
+  atom = stsz_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->sample_size_ = read_32(buffer + 4);
+  atom->entries_ = read_32(buffer + 8);
+  buffer += 12;
+
+  // fix for clayton.mp4, it mistakenly says there is 1 entry
+//  if(atom->sample_size_ && atom->entries_)
+//    atom->entries_ = 0;
+
+  if(!atom->sample_size_)
+  {
+    if(size < 12 + atom->entries_ * sizeof(uint32_t))
+    {
+      MP4_ERROR("%s", "Error: stsz.entries don't match with size\n");
+      stsz_exit(atom);
+      return 0;
+    }
+
+    atom->sample_sizes_ = (uint32_t*)malloc(atom->entries_ * sizeof(uint32_t));
+    for(i = 0; i != atom->entries_; ++i)
+    {
+      atom->sample_sizes_[i] = read_32(buffer);
+      buffer += 4;
+    }
+  }
+
+  return atom;
+}
+
+static void* stsc_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stsc_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = stsc_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+
+  if(size < 8 + atom->entries_ * sizeof(stsc_table_t))
+    return 0;
+
+  buffer += 8;
+
+  // reserve space for one extra entry as when splitting the video we may have to
+  // split the first entry
+  atom->table_ = (stsc_table_t*)(malloc((atom->entries_ + 1) * sizeof(stsc_table_t)));
+
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    atom->table_[i].chunk_ = read_32(buffer + 0) - 1; // Note: we use zero based
+    atom->table_[i].samples_ = read_32(buffer + 4);
+    atom->table_[i].id_ = read_32(buffer + 8);
+    buffer += 12;
+  }
+
+  return atom;
+}
+
+static void* stss_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stss_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = stss_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+
+  if(size < 8 + atom->entries_ * sizeof(uint32_t))
+    return 0;
+
+  buffer += 8;
+
+  atom->sample_numbers_ = (uint32_t*)malloc(atom->entries_ * sizeof(uint32_t));
+
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    atom->sample_numbers_[i] = read_32(buffer);
+    buffer += 4;
+  }
+
+  return atom;
+}
+
+static int mp4_read_desc_len(unsigned char** buffer)
+{
+  uint32_t len = 0;
+  unsigned int bytes = 0;
+  for(;;)
+  {
+    unsigned int c = read_8(*buffer + bytes);
+    len <<= 7;
+    len |= (c & 0x7f);
+    if(++bytes == 4)
+      break;
+    if(!(c & 0x80))
+      break;
+  }
+
+  *buffer += bytes;
+
+  return len;
+}
+
+static int esds_read(mp4_context_t const* mp4_context,
+                     sample_entry_t* sample_entry,
+                     unsigned char* buffer, uint64_t size)
+{
+  unsigned int tag;
+  unsigned int len;
+
+  uint16_t stream_id;
+  unsigned int stream_priority;
+//  unsigned int object_type_id;
+  unsigned int stream_type;
+  unsigned int buffer_size_db;
+
+  if(size < 9)
+    return 0;
+
+  /* unsigned char version = */ read_8(buffer);
+  /* unsigned int flags = */ read_24(buffer + 1);
+
+  buffer += 4;
+
+  // ES_DescrTag
+  tag = read_8(buffer);
+  buffer += 1;
+  if(tag == MP4_ELEMENTARY_STREAM_DESCRIPTOR_TAG)
+  {
+    len = mp4_read_desc_len(&buffer);
+    MP4_INFO("Elementary Stream Descriptor: len=%u\n", len);
+    stream_id = read_16(buffer + 0);
+    stream_priority = read_8(buffer + 2);
+    buffer += 3;
+  }
+  else
+  {
+    MP4_INFO("Elementary Stream Descriptor: len=%u\n", 2);
+    stream_id = read_16(buffer + 0);
+    buffer += 2;
+  }
+
+  tag = read_8(buffer);
+  buffer += 1;
+  len = mp4_read_desc_len(&buffer);
+  MP4_INFO("MPEG: tag=%u len=%u\n", tag, len);
+
+  // Decoder config descr Tag
+  if(tag != MP4_DECODER_CONFIG_DESCRIPTOR_TAG)
+  {
+    MP4_INFO("Decoder Config Descriptor: len=%u\n", len);
+    return 0;
+  }
+
+  sample_entry->object_type_id_ = read_8(buffer);
+  buffer += 1; // object_type_id
+
+  stream_type = read_8(buffer);
+  buffer += 1; // stream_type
+
+  buffer_size_db = read_24(buffer);
+  buffer += 3; // buffer_size_db
+
+  sample_entry->max_bitrate_ = read_32(buffer);
+  buffer += 4;
+
+  sample_entry->avg_bitrate_ = read_32(buffer);
+  buffer += 4; // avg_bitrate
+
+  MP4_INFO("%s", "Decoder Configuration Descriptor:\n");
+  MP4_INFO("  object_type_id=$%02x\n", sample_entry->object_type_id_);
+  MP4_INFO("  stream_type=%u\n", stream_type);
+  MP4_INFO("  buffer_size_db=%u\n", buffer_size_db);
+  MP4_INFO("  max_bitrate=%u\n", sample_entry->max_bitrate_);
+  MP4_INFO("  avg_bitrate=%u\n", sample_entry->avg_bitrate_);
+
+  switch(sample_entry->object_type_id_)
+  {
+  case MP4_MPEG2AudioMain:
+  case MP4_MPEG2AudioLowComplexity:
+  case MP4_MPEG2AudioScaleableSamplingRate:
+  case MP4_MPEG4Audio:
+    sample_entry->wFormatTag = 0x00ff;  // WAVE_FORMAT_RAW_AAC1
+    break;
+  case MP4_MPEG1Audio:
+  case MP4_MPEG2AudioPart3:
+    sample_entry->wFormatTag = 0x0055;  // WAVE_FORMAT_MP3
+    break;
+  default:
+    break;
+  }
+
+  if(!sample_entry->nAvgBytesPerSec)
+  {
+    unsigned int bitrate = sample_entry->avg_bitrate_;
+    if(!bitrate)
+      bitrate = sample_entry->max_bitrate_;
+    sample_entry->nAvgBytesPerSec = bitrate / 8;
+  }
+
+  tag = read_8(buffer);
+  buffer += 1;
+  len = mp4_read_desc_len(&buffer);
+  MP4_INFO("MPEG: tag=%u len=%u\n", tag, len);
+  // Decoder specific descr Tag
+  if(tag == MP4_DECODER_SPECIFIC_DESCRIPTOR_TAG)
+  {
+    MP4_INFO("Decoder Specific Info Descriptor: len=%u\n", len);
+    sample_entry->codec_private_data_length_ = len;
+    sample_entry->codec_private_data_ = buffer;
+  }
+
+  return 1;
+}
+
+static int
+stsd_parse_vide(mp4_context_t const* mp4_context,
+                trak_t* UNUSED(trak),
+                sample_entry_t* sample_entry)
+{
+  unsigned char* buffer = sample_entry->buf_;
+  unsigned char* buffer_start = buffer;
+  uint64_t size = sample_entry->len_;
+  unsigned int i;
+
+  if(size < 78)
+  {
+    MP4_ERROR("%s", "invalid stsd video size\n");
+    return 0;
+  }
+
+  // 'ovc1' is immediately followed by additional data and ends with the codec
+  // private data, *not* by additional atoms.
+  if(sample_entry->fourcc_ == FOURCC('o', 'v', 'c', '1'))
+  {
+    // TODO: get start of ovc1 codec private data (25 00 00 01 0F CB 6C 1A ..)
+    sample_entry->codec_private_data_ = buffer + 190;
+    sample_entry->codec_private_data_length_ = (unsigned int)(size - 190);
+    return 1;
+  }
+
+  if(size >= 78 + ATOM_PREAMBLE_SIZE)
+  {
+    atom_t atom;
+    buffer += 78;
+    while(buffer < buffer_start + size - ATOM_PREAMBLE_SIZE)
+    {
+      buffer = atom_read_header(mp4_context, buffer, &atom);
+
+      if(buffer == NULL)
+      {
+        return 0;
+      }
+
+      switch(atom.type_)
+      {
+      case FOURCC('a', 'v', 'c', 'C'):
+      {
+        unsigned int sequence_parameter_sets;
+        unsigned int picture_parameter_sets;
+        unsigned int configuration_version;
+        unsigned int profile_indication;
+        unsigned int profile_compatibility;
+        unsigned int level_indication;
+
+        sample_entry->codec_private_data_ = buffer;
+
+        configuration_version = read_8(buffer + 0);
+        profile_indication = read_8(buffer + 1);
+        profile_compatibility = read_8(buffer + 2);
+        level_indication = read_8(buffer + 3);
+
+        MP4_INFO("avcC: profile %s, level %d.%d compatibility=$%02x\n",
+                 profile_indication == H264_PROFILE_BASELINE ? "Baseline" :
+                 profile_indication == H264_PROFILE_MAIN ? "Main" :
+                 profile_indication == H264_PROFILE_HIGH ? "High" :
+                 "> High",
+                 level_indication / 10, level_indication % 10,
+                 profile_compatibility);
+
+        sample_entry->nal_unit_length_ = (read_8(buffer + 4) & 3) + 1;
+        sequence_parameter_sets = read_8(buffer + 5) & 0x1f;
+        buffer += 6;
+        for(i = 0; i != sequence_parameter_sets; ++i)
+        {
+          unsigned int sps_length = read_16(buffer);
+          buffer += 2;
+          sample_entry->sps_ = buffer;
+          sample_entry->sps_length_ = sps_length;
+          buffer +=  sps_length;
+        }
+
+        picture_parameter_sets = read_8(buffer);
+        buffer += 1;
+        for(i = 0; i != picture_parameter_sets; ++i)
+        {
+          unsigned int pps_length = read_16(buffer);
+          buffer += 2;
+          sample_entry->pps_ = buffer;
+          sample_entry->pps_length_ = pps_length;
+          buffer += pps_length;
+        }
+        sample_entry->codec_private_data_length_ =
+          (unsigned int)(buffer - sample_entry->codec_private_data_);
+      }
+        break;
+      case FOURCC('e', 's', 'd', 's'):
+        if(!esds_read(mp4_context, sample_entry, buffer, atom.size_ - ATOM_PREAMBLE_SIZE))
+        {
+          return 0;
+        }
+        break;
+      default:
+        break;
+      }
+      buffer = atom.end_;
+    }
+  }
+
+  return 1;
+}
+
+static int wave_read(mp4_context_t const* mp4_context,
+                     sample_entry_t* sample_entry,
+                     unsigned char* buffer, uint64_t size)
+{
+  unsigned char* end = buffer + size;
+  while(buffer < end)
+  {
+    atom_t atom;
+    buffer = atom_read_header(mp4_context, buffer, &atom);
+
+    if(buffer == NULL)
+    {
+      return 0;
+    }
+
+    switch(atom.type_)
+    {
+    case FOURCC('e', 's', 'd', 's'):
+      if(!esds_read(mp4_context, sample_entry, buffer, atom.size_ - ATOM_PREAMBLE_SIZE))
+      {
+        return 0;
+      }
+      break;
+    }
+
+    buffer = atom.end_;
+  }
+
+  return 1;
+}
+
+static int
+stsd_parse_soun(mp4_context_t const* mp4_context,
+                trak_t* UNUSED(trak),
+                sample_entry_t* sample_entry)
+{
+  unsigned char* buffer = sample_entry->buf_;
+  unsigned char* buffer_start = buffer;
+  uint64_t size = sample_entry->len_;
+
+  unsigned int data_reference_index;
+  unsigned int version;
+  unsigned int revision;
+  unsigned int vendor;
+  unsigned int compression_id;
+  unsigned int packet_size;
+
+  if(sample_entry->len_ < 28)
+    return 0;
+
+  data_reference_index = read_16(buffer + 6);
+
+  version = read_16(buffer + 8);
+  revision = read_16(buffer + 10);
+  vendor = read_32(buffer + 12);
+
+  sample_entry->nChannels = read_16(buffer + 16);
+
+  if(sample_entry->nChannels == 3)
+    sample_entry->nChannels = 6;
+
+  sample_entry->wBitsPerSample = read_16(buffer + 18);
+
+  compression_id = read_16(buffer + 20);
+  packet_size = read_16(buffer + 22);
+
+  // samplerate = {timescale of media} << 16
+  sample_entry->samplerate_hi_ = read_16(buffer + 24);
+  sample_entry->samplerate_lo_ = read_16(buffer + 26);
+
+  sample_entry->nSamplesPerSec = sample_entry->samplerate_hi_;
+
+  MP4_INFO("%s", "Sample Entry:\n");
+  MP4_INFO("  data_reference_index=%u\n", data_reference_index);
+  MP4_INFO("  version=%u\n", version);
+  MP4_INFO("  revision=%u\n", revision);
+  MP4_INFO("  vendor=%08x\n", vendor);
+  MP4_INFO("  channel_count=%u\n", sample_entry->nChannels);
+  MP4_INFO("  sample_size=%u\n", sample_entry->wBitsPerSample);
+  MP4_INFO("  compression_id=%u\n", compression_id);
+  MP4_INFO("  packet_size=%u\n", packet_size);
+  MP4_INFO("  samplerate_hi=%u\n", sample_entry->samplerate_hi_);
+  MP4_INFO("  samplerate_lo=%u\n", sample_entry->samplerate_lo_);
+
+  buffer += 28;
+
+  // 'owma' is immediately followed by the codec private data, *not* by
+  // additional atoms.
+  if(sample_entry->fourcc_ == FOURCC('o', 'w', 'm', 'a'))
+  {
+    sample_entry->codec_private_data_ = buffer;
+    sample_entry->codec_private_data_length_ = (unsigned int)(size - 28);
+//    sample_entry->wFormatTag = read_16(buffer + 0);
+//    ...
+
+    return 1;
+  }
+
+  if(version >= 1)
+  {
+    unsigned int samples_per_packet;
+    unsigned int bytes_per_packet;
+    unsigned int bytes_per_frame;
+    unsigned int bytes_per_sample;
+
+    if(version == 1 && size < 28 + 16)
+    {
+      return 0;
+    }
+    if(version == 2 && size < 28 + 36)
+    {
+      return 0;
+    }
+    if(version > 2)
+    {
+      return 0;
+    }
+
+    samples_per_packet = read_32(buffer + 0);
+    bytes_per_packet = read_32(buffer + 4);
+    bytes_per_frame = read_32(buffer + 8);
+    bytes_per_sample = read_32(buffer + 12);
+
+    MP4_INFO("  samples_per_packet=%u\n", samples_per_packet);
+    MP4_INFO("  bytes_per_packet=%u\n", bytes_per_packet);
+    MP4_INFO("  bytes_per_frame=%u\n", bytes_per_frame);
+    MP4_INFO("  bytes_per_sample=%u\n", bytes_per_sample);
+
+    if(samples_per_packet > 0)
+    {
+      sample_entry->nAvgBytesPerSec =
+        (sample_entry->nChannels * sample_entry->nSamplesPerSec *
+         bytes_per_packet + samples_per_packet / 2) / samples_per_packet;
+      sample_entry->nBlockAlign = (uint16_t)bytes_per_frame;
+    }
+    else
+    {
+      sample_entry->nAvgBytesPerSec =
+        sample_entry->nChannels * sample_entry->nSamplesPerSec *
+        sample_entry->wBitsPerSample / 8;
+    }
+
+    buffer += version == 1 ? 16 : 36;
+  }
+
+  if(buffer - buffer_start >= ATOM_PREAMBLE_SIZE)
+  {
+    atom_t atom;
+    while(buffer < buffer_start + size - ATOM_PREAMBLE_SIZE)
+    {
+      buffer = atom_read_header(mp4_context, buffer, &atom);
+
+      if(buffer == NULL)
+      {
+        return 0;
+      }
+
+      switch(atom.type_)
+      {
+      case FOURCC('w', 'a', 'v', 'e'):
+        if(!wave_read(mp4_context, sample_entry, buffer, atom.size_ - ATOM_PREAMBLE_SIZE))
+        {
+          return 0;
+        }
+        break;
+      case FOURCC('f', 'r', 'm', 'a'):
+        break;
+      case FOURCC('e', 's', 'd', 's'):
+        if(!esds_read(mp4_context, sample_entry, buffer, atom.size_ - ATOM_PREAMBLE_SIZE))
+        {
+          return 0;
+        }
+        break;
+      default:
+        break;
+      }
+
+      buffer = atom.end_;
+    }
+  }
+
+  return 1;
+}
+
+static int stsd_parse(mp4_context_t const* mp4_context,
+                      trak_t* trak, stsd_t* stsd)
+{
+  unsigned int i;
+  for(i = 0; i != stsd->entries_; ++i)
+  {
+    sample_entry_t* sample_entry = &stsd->sample_entries_[i];
+    switch(trak->mdia_->hdlr_->handler_type_)
+    {
+      case FOURCC('v', 'i', 'd', 'e'):
+        if(!stsd_parse_vide(mp4_context, trak, sample_entry))
+        {
+          return 0;
+        }
+        break;
+      case FOURCC('s', 'o', 'u', 'n'):
+        if(!stsd_parse_soun(mp4_context, trak, sample_entry))
+        {
+          return 0;
+        }
+        break;
+      case FOURCC('h', 'i', 'n', 't'):
+      default:
+        return 1;
+    }
+  }
+
+  return 1;
+}
+
+static void* stts_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stts_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = stts_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+
+  if(size < 8 + atom->entries_ * sizeof(stts_table_t))
+    return 0;
+
+  buffer += 8;
+
+  atom->table_ = (stts_table_t*)(malloc(atom->entries_ * sizeof(stts_table_t)));
+
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    atom->table_[i].sample_count_ = read_32(buffer + 0);
+    atom->table_[i].sample_duration_ = read_32(buffer + 4);
+    buffer += 8;
+  }
+
+  return atom;
+}
+
+static void* stsd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  stsd_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = stsd_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entries_ = read_32(buffer + 4);
+
+  buffer += 8;
+
+  atom->sample_entries_ = (sample_entry_t*)(malloc(atom->entries_ * sizeof(sample_entry_t)));
+
+  for(i = 0; i != atom->entries_; ++i)
+  {
+    unsigned int j;
+    sample_entry_t* sample_entry = &atom->sample_entries_[i];
+    sample_entry_init(sample_entry);
+    sample_entry->len_ = read_32(buffer) - 8;
+    sample_entry->fourcc_ = read_32(buffer + 4);
+    sample_entry->buf_ = (unsigned char*)malloc(sample_entry->len_);
+    buffer += 8;
+    for(j = 0; j != sample_entry->len_; ++j)
+    {
+      sample_entry->buf_[j] = (unsigned char)read_8(buffer + j);
+    }
+    buffer += j;
+  }
+
+  return atom;
+}
+
+static int stbl_add_stsd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->stsd_ = (stsd_t*)child;
+
+  return 1;
+}
+
+static int stbl_add_stts(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->stts_ = (stts_t*)child;
+
+  return 1;
+}
+
+static int stbl_add_stss(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->stss_ = (stss_t*)child;
+
+  return 1;
+}
+
+static int stbl_add_stsc(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->stsc_ = (stsc_t*)child;
+
+  return 1;
+}
+
+static int stbl_add_stsz(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->stsz_ = (stsz_t*)child;
+
+  return 1;
+}
+
+static int stbl_add_stco(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->stco_ = (stco_t*)child;
+
+  return 1;
+}
+
+static int stbl_add_ctts(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  stbl_t* stbl = (stbl_t*)parent;
+  stbl->ctts_ = (ctts_t*)child;
+
+  return 1;
+}
+
+
+static void* stbl_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  stbl_t* atom = stbl_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('s', 't', 's', 'd'), &stbl_add_stsd, &stsd_read },
+    { FOURCC('s', 't', 't', 's'), &stbl_add_stts, &stts_read },
+    { FOURCC('s', 't', 's', 's'), &stbl_add_stss, &stss_read },
+    { FOURCC('s', 't', 's', 'c'), &stbl_add_stsc, &stsc_read },
+    { FOURCC('s', 't', 's', 'z'), &stbl_add_stsz, &stsz_read },
+    { FOURCC('s', 't', 'c', 'o'), &stbl_add_stco, &stco_read },
+    { FOURCC('c', 'o', '6', '4'), &stbl_add_stco, &co64_read },
+    { FOURCC('c', 't', 't', 's'), &stbl_add_ctts, &ctts_read },
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->stsd_)
+  {
+    MP4_ERROR("%s", "stbl: missing mandatory stsd\n");
+    result = 0;
+  }
+
+  if(!atom->stts_)
+  {
+    MP4_ERROR("%s", "stbl: missing mandatory stts\n");
+    result = 0;
+  }
+
+  // Expression Encoder doesn't write mandatory stsz atom
+  if(!atom->stsc_)
+  {
+    MP4_ERROR("%s", "stbl: missing mandatory stsc\n");
+//    result = 0;
+  }
+
+  // Expression Encoder doesn't write mandatory stsz atom
+  if(!atom->stsz_)
+  {
+    MP4_ERROR("%s", "stbl: missing mandatory stsz\n");
+//    result = 0;
+  }
+
+  // Expression Encoder doesn't write mandatory stco atom
+  if(!atom->stco_)
+  {
+    MP4_ERROR("%s", "stbl: missing mandatory stco\n");
+//    result = 0;
+  }
+
+  if(!result)
+  {
+    stbl_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static void* hdlr_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  hdlr_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = hdlr_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->predefined_ = read_32(buffer + 4);
+  atom->handler_type_ = read_32(buffer + 8);
+  atom->reserved1_ = read_32(buffer + 12);
+  atom->reserved2_ = read_32(buffer + 16);
+  atom->reserved3_ = read_32(buffer + 20);
+  buffer += 24;
+  size -= 24;
+  if(size > 0)
+  {
+    size_t length = (size_t)size;
+    atom->name_ = (char*)malloc(length + 1);
+    if(atom->predefined_ == FOURCC('m', 'h', 'l', 'r'))
+    {
+      length = read_8(buffer);
+      buffer += 1;
+      if(size < length)
+        length = (size_t)size;
+    }
+    memcpy(atom->name_, buffer, length);
+    atom->name_[length] = '\0';
+  }
+
+  return atom;
+}
+
+static void* vmhd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  vmhd_t* atom;
+
+  if(size < 12)
+    return 0;
+
+  atom = vmhd_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->graphics_mode_ = read_16(buffer + 4);
+  buffer += 6;
+  for(i = 0; i != 3; ++i)
+  {
+    atom->opcolor_[i] = read_16(buffer);
+    buffer += 2;
+  }
+
+  return atom;
+}
+
+static void* smhd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  smhd_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = smhd_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->balance_ = read_16(buffer + 4);
+  atom->reserved_ = read_16(buffer + 6);
+
+  return atom;
+}
+
+static int dinf_add_dref(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  dinf_t* dinf = (dinf_t*)parent;
+  dinf->dref_ = (dref_t*)child;
+
+  return 1;
+}
+
+static void* dref_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  dref_t* atom;
+
+  if(size < 20)
+    return 0;
+
+  atom = dref_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->entry_count_ = read_32(buffer + 4);
+  atom->table_ = atom->entry_count_ == 0 ? NULL : (dref_table_t*)malloc(atom->entry_count_ * sizeof(dref_table_t));
+  buffer += 8;
+
+  for(i = 0; i != atom->entry_count_; ++i)
+  {
+    dref_table_t* entry = &atom->table_[i];
+    uint32_t entry_size = read_32(buffer + 0);
+    uint32_t type = read_32(buffer + 4);
+    uint32_t flags = read_32(buffer + 8);
+    dref_table_init(entry);
+    entry->flags_ = flags;
+    if(flags != 0x000001)
+    {
+      switch(type)
+      {
+        case FOURCC('u', 'r', 'n', ' '):
+          // read name and location (optional) as UTF8 zero-terminated string
+          break;
+        case FOURCC('u', 'r', 'l', ' '):
+          // read location as UTF8 zero-terminated string
+          break;
+      }
+    }
+    buffer += entry_size;
+  }
+
+  return atom;
+}
+
+
+static void* dinf_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  dinf_t* atom = dinf_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('d', 'r', 'e', 'f'), &dinf_add_dref, &dref_read },
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->dref_)
+  {
+    MP4_ERROR("%s", "dinf: missing dref\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    dinf_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static int minf_add_vmhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  minf_t* minf = (minf_t*)parent;
+  minf->vmhd_ = (vmhd_t*)child;
+
+  return 1;
+}
+
+static int minf_add_smhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  minf_t* minf = (minf_t*)parent;
+  minf->smhd_ = (smhd_t*)child;
+
+  return 1;
+}
+
+static int minf_add_dinf(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  minf_t* minf = (minf_t*)parent;
+  minf->dinf_ = (dinf_t*)child;
+
+  return 1;
+}
+
+static int minf_add_stbl(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  minf_t* minf = (minf_t*)parent;
+  minf->stbl_ = (stbl_t*)child;
+
+  return 1;
+}
+
+static void* minf_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  minf_t* atom = minf_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('v', 'm', 'h', 'd'), &minf_add_vmhd, &vmhd_read },
+    { FOURCC('s', 'm', 'h', 'd'), &minf_add_smhd, &smhd_read },
+    { FOURCC('d', 'i', 'n', 'f'), &minf_add_dinf, &dinf_read },
+    { FOURCC('s', 't', 'b', 'l'), &minf_add_stbl, &stbl_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->stbl_)
+  {
+    MP4_ERROR("%s", "minf: missing stbl\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    minf_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+
+static void* mdhd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t UNUSED(size))
+{
+  uint16_t language;
+  unsigned int i;
+
+  mdhd_t* mdhd = mdhd_init();
+  mdhd->version_ = read_8(buffer + 0);
+  mdhd->flags_ = read_24(buffer + 1);
+  if(mdhd->version_ == 0)
+  {
+    mdhd->creation_time_ = read_32(buffer + 4);
+    mdhd->modification_time_ = read_32(buffer + 8);
+    mdhd->timescale_ = read_32(buffer + 12);
+    mdhd->duration_ = read_32(buffer + 16);
+    buffer += 20;
+  }
+  else
+  {
+    mdhd->creation_time_ = read_64(buffer + 4);
+    mdhd->modification_time_ = read_64(buffer + 12);
+    mdhd->timescale_ = read_32(buffer + 20);
+    mdhd->duration_ = read_64(buffer + 24);
+    buffer += 32;
+  }
+
+  language = read_16(buffer + 0);
+  for(i = 0; i != 3; ++i)
+  {
+    mdhd->language_[i] = ((language >> ((2 - i) * 5)) & 0x1f) + 0x60;
+  }
+
+  mdhd->predefined_ = read_16(buffer + 2);
+
+  return mdhd;
+}
+
+
+static void* tkhd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  tkhd_t* tkhd = tkhd_init();
+
+  tkhd->version_ = read_8(buffer + 0);
+  tkhd->flags_ = read_24(buffer + 1);
+  if(tkhd->version_ == 0)
+  {
+    if(size < 92-8)
+      return 0;
+
+    tkhd->creation_time_ = read_32(buffer + 4);
+    tkhd->modification_time_ = read_32(buffer + 8);
+    tkhd->track_id_ = read_32(buffer + 12);
+    tkhd->reserved_ = read_32(buffer + 16);
+    tkhd->duration_ = read_32(buffer + 20);
+    buffer += 24;
+  }
+  else
+  {
+    if(size < 104-8)
+      return 0;
+
+    tkhd->creation_time_ = read_64(buffer + 4);
+    tkhd->modification_time_ = read_64(buffer + 12);
+    tkhd->track_id_ = read_32(buffer + 20);
+    tkhd->reserved_ = read_32(buffer + 24);
+    tkhd->duration_ = read_64(buffer + 28);
+    buffer += 36;
+  }
+
+  tkhd->reserved2_[0] = read_32(buffer + 0);
+  tkhd->reserved2_[1] = read_32(buffer + 4);
+  tkhd->layer_ = read_16(buffer + 8);
+  tkhd->predefined_ = read_16(buffer + 10);
+  tkhd->volume_ = read_16(buffer + 12);
+  tkhd->reserved3_ = read_16(buffer + 14);
+  buffer += 16;
+
+  for(i = 0; i != 9; ++i)
+  {
+    tkhd->matrix_[i] = read_32(buffer);
+    buffer += 4;
+  }
+
+  tkhd->width_ = read_32(buffer + 0);
+  tkhd->height_ = read_32(buffer + 4);
+
+  return tkhd;
+}
+
+static int mdia_add_mdhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  mdia_t* mdia = (mdia_t*)parent;
+  mdia->mdhd_ = (mdhd_t*)child;
+
+  return 1;
+}
+
+static int mdia_add_hdlr(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  mdia_t* mdia = (mdia_t*)parent;
+  mdia->hdlr_ = (hdlr_t*)child;
+
+  return 1;
+}
+
+static int mdia_add_minf(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  mdia_t* mdia = (mdia_t*)parent;
+  mdia->minf_ = (minf_t*)child;
+
+  return 1;
+}
+
+static void* mdia_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  mdia_t* atom = mdia_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('m', 'd', 'h', 'd'), &mdia_add_mdhd, &mdhd_read },
+    { FOURCC('h', 'd', 'l', 'r'), &mdia_add_hdlr, &hdlr_read },
+    { FOURCC('m', 'i', 'n', 'f'), &mdia_add_minf, &minf_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->mdhd_)
+  {
+    MP4_ERROR("%s", "mdia: missing mdhd\n");
+    result = 0;
+  }
+
+  if(!atom->hdlr_)
+  {
+    MP4_ERROR("%s", "mdia: missing hdlr\n");
+    result = 0;
+  }
+
+  if(!atom->minf_)
+  {
+    MP4_ERROR("%s", "mdia: missing minf\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    mdia_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static void* elst_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  elst_t* atom;
+
+  if(size < 8)
+    return 0;
+
+  atom = elst_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  atom->entry_count_ = read_32(buffer + 4);
+
+  buffer += 8;
+
+  atom->table_ = (elst_table_t*)(malloc(atom->entry_count_ * sizeof(elst_table_t)));
+
+  for(i = 0; i != atom->entry_count_; ++i)
+  {
+    elst_table_t* elst_table = &atom->table_[i];
+    if(atom->version_ == 0)
+    {
+      elst_table->segment_duration_ = read_32(buffer);
+      elst_table->media_time_ = (int32_t)read_32(buffer + 4);
+      buffer += 8;
+    }
+    else
+    {
+      elst_table->segment_duration_ = read_64(buffer);
+      elst_table->media_time_ = read_64(buffer + 8);
+      buffer += 16;
+    }
+
+    elst_table->media_rate_integer_ = read_16(buffer);
+    elst_table->media_rate_fraction_ = read_16(buffer + 2);
+    buffer += 4;
+  }
+
+  return atom;
+}
+
+static int edts_add_elst(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* elst)
+{
+  edts_t* edts = (edts_t*)parent;
+  edts->elst_ = (elst_t*)elst;
+
+  return 1;
+}
+
+static void* edts_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  edts_t* atom = edts_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('e', 'l', 's', 't'), &edts_add_elst, &elst_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  if(!result)
+  {
+    edts_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static int trak_add_tkhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* tkhd)
+{
+  trak_t* trak = (trak_t*)parent;
+  trak->tkhd_ = (tkhd_t*)tkhd;
+
+  return 1;
+}
+
+static int trak_add_mdia(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* mdia)
+{
+  trak_t* trak = (trak_t*)parent;
+  trak->mdia_ = (mdia_t*)mdia;
+
+  return 1;
+}
+
+static int trak_add_edts(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* edts)
+{
+  trak_t* trak = (trak_t*)parent;
+  trak->edts_ = (edts_t*)edts;
+
+  return 1;
+}
+
+static void* trak_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  trak_t* atom = trak_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('t', 'k', 'h', 'd'), &trak_add_tkhd, &tkhd_read },
+    { FOURCC('m', 'd', 'i', 'a'), &trak_add_mdia, &mdia_read },
+    { FOURCC('e', 'd', 't', 's'), &trak_add_edts, &edts_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->tkhd_)
+  {
+    MP4_ERROR("%s", "trak: missing tkhd\n");
+    result = 0;
+  }
+
+  if(!atom->mdia_)
+  {
+    MP4_ERROR("%s", "trak: missing mdia\n");
+    result = 0;
+  }
+
+  if(result && !stsd_parse(mp4_context, atom, atom->mdia_->minf_->stbl_->stsd_))
+  {
+    MP4_ERROR("%s", "trak: error parsing stsd\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    trak_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static void* mvhd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  mvhd_t* atom = mvhd_init();
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+  if(atom->version_ == 0)
+  {
+    if(size < 108-8)
+      return 0;
+
+    atom->creation_time_ = read_32(buffer + 4);
+    atom->modification_time_ = read_32(buffer + 8);
+    atom->timescale_ = read_32(buffer + 12);
+    atom->duration_ = read_32(buffer + 16);
+    buffer += 20;
+  }
+  else
+  {
+    if(size < 120-8)
+      return 0;
+
+    atom->creation_time_ = read_64(buffer + 4);
+    atom->modification_time_ = read_64(buffer + 12);
+    atom->timescale_ = read_32(buffer + 20);
+    atom->duration_ = read_64(buffer + 24);
+    buffer += 32;
+  }
+  atom->rate_ = read_32(buffer + 0);
+  atom->volume_ = read_16(buffer + 4);
+  atom->reserved1_ = read_16(buffer + 6);
+  atom->reserved2_[0] = read_32(buffer + 8);
+  atom->reserved2_[1] = read_32(buffer + 12);
+  buffer += 16;
+
+  for(i = 0; i != 9; ++i)
+  {
+    atom->matrix_[i] = read_32(buffer);
+    buffer += 4;
+  }
+
+  for(i = 0; i != 6; ++i)
+  {
+    atom->predefined_[i] = read_32(buffer);
+    buffer += 4;
+  }
+
+  atom->next_track_id_ = read_32(buffer + 0);
+
+  return atom;
+}
+
+
+static int moov_add_mvhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* mvhd)
+{
+  moov_t* moov = (moov_t*)parent;
+  moov->mvhd_ = (mvhd_t*)mvhd;
+
+  return 1;
+}
+
+static int moov_add_trak(mp4_context_t const* mp4_context,
+                         void* parent, void* child)
+{
+  moov_t* moov = (moov_t*)parent;
+  trak_t* trak = (trak_t*)child;
+  if(moov->tracks_ == MAX_TRACKS)
+  {
+    trak_exit(trak);
+    return 0;
+  }
+
+  if(trak->mdia_->hdlr_->handler_type_ != FOURCC('v', 'i', 'd', 'e') &&
+     trak->mdia_->hdlr_->handler_type_ != FOURCC('s', 'o', 'u', 'n'))
+  {
+    MP4_INFO("Trak ignored (handler_type=%c%c%c%c, name=%s)\n",
+      trak->mdia_->hdlr_->handler_type_ >> 24,
+      trak->mdia_->hdlr_->handler_type_ >> 16,
+      trak->mdia_->hdlr_->handler_type_ >> 8,
+      trak->mdia_->hdlr_->handler_type_,
+      trak->mdia_->hdlr_->name_);
+    trak_exit(trak);
+    return 1; // continue
+  }
+
+  // check for tracks that have a duration, but no samples. This happens with
+  // Expression Encoder fragmented movie files.
+  if(trak->mdia_->minf_->stbl_->stco_ == 0 ||
+    (trak->mdia_->minf_->stbl_->stco_->entries_ == 0 &&
+     trak->mdia_->mdhd_->duration_))
+  {
+    trak->mdia_->mdhd_->duration_ = 0;
+  }
+
+#if 0  // we can't ignore empty tracks, as the fragments may come later
+  // ignore empty track (unless LIVE)
+  if(trak->mdia_->mdhd_->duration_ == 0 && !moov->mvex_)
+  {
+    trak_exit(trak);
+    return 1; // continue
+  }
+#endif
+  
+  moov->traks_[moov->tracks_] = trak;
+  ++moov->tracks_;
+
+  return 1;
+}
+
+static void* trex_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  trex_t* atom = trex_init();
+
+  if(size < 24)
+    return 0;
+
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->track_id_ = read_32(buffer + 4);
+  atom->default_sample_description_index_ = read_32(buffer + 8);
+  atom->default_sample_duration_ = read_32(buffer + 12);
+  atom->default_sample_size_ = read_32(buffer + 16);
+  atom->default_sample_flags_ = read_32(buffer + 20);
+
+  return atom;
+}
+
+static int moov_add_mvex(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* mvex)
+{
+  moov_t* moov = (moov_t*)parent;
+  moov->mvex_ = (mvex_t*)mvex;
+
+  return 1;
+}
+
+static int mvex_add_trex(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  mvex_t* mvex = (mvex_t*)parent;
+  trex_t* trex = (trex_t*)child;
+  if(mvex->tracks_ == MAX_TRACKS)
+  {
+    trex_exit(trex);
+    return 0;
+  }
+
+  mvex->trexs_[mvex->tracks_] = trex;
+  ++mvex->tracks_;
+
+  return 1;
+}
+
+static void* mvex_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  mvex_t* atom = mvex_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('t', 'r', 'e', 'x'), &mvex_add_trex, &trex_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->tracks_)
+  {
+    MP4_ERROR("%s", "mvex: missing trex\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    mvex_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+extern void* moov_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  moov_t* atom = moov_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('m', 'v', 'h', 'd'), &moov_add_mvhd, &mvhd_read },
+    { FOURCC('t', 'r', 'a', 'k'), &moov_add_trak, &trak_read },
+    { FOURCC('m', 'v', 'e', 'x'), &moov_add_mvex, &mvex_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->mvhd_)
+  {
+    MP4_ERROR("%s", "moov: missing mvhd\n");
+    result = 0;
+  }
+
+  if(!atom->tracks_)
+  {
+    MP4_ERROR("%s", "moov: missing trak\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    moov_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static int add_fragmented_samples(mp4_context_t const* mp4_context,
+                                  traf_t const* traf)
+{
+  unsigned int track;
+  moov_t* moov = mp4_context->moov;
+  trak_t* trak = NULL;
+  trun_t* trun;
+  for(track = 0; track != moov->tracks_; ++track)
+  {
+    trak = moov->traks_[track];
+    if(trak->tkhd_->track_id_ == traf->tfhd_->track_id_)
+      break;
+  }
+  if(track == moov->tracks_)
+  {
+    MP4_ERROR("%s", "add_fragmented_samples: trak not found\n");
+    return 0;
+  }
+
+  trun = traf->trun_;
+  for(; trun != NULL; trun = trun->next_)
+  {
+    tfhd_t const* tfhd = traf->tfhd_;
+//    trun_t const* trun = traf->trun_;
+
+    unsigned int i;
+    unsigned int s = trak->samples_size_;
+
+    uint64_t data_offset = tfhd->base_data_offset_ + trun->data_offset_;
+//    int64_t pts = trak->fragment_pts_;  // trak->mdia_->mdhd_->duration_;
+    int64_t pts = trak->mdia_->mdhd_->duration_;
+    unsigned int cto = 0;
+
+    //
+    if(pts == 0 && trak->edts_)
+    {
+      elst_t const* elst = trak->edts_->elst_;
+      if(elst && elst->entry_count_ > 0)
+      {
+        elst_table_t* elst_table = &elst->table_[0];
+        if(elst_table->media_time_ >= -1)
+        {
+          pts = elst_table->media_time_ != -1 ? elst_table->media_time_
+                                              : (int64_t)elst_table->segment_duration_;
+          trak->mdia_->mdhd_->duration_ = pts;
+//            trak->fragment_pts_ = pts;
+        }
+      }
+    }
+
+    trak->samples_size_ += trun->sample_count_;
+
+    // reserve one extra for the end information (like pts and cto).
+    trak->samples_ = (samples_t*)realloc(trak->samples_,
+      (trak->samples_size_ + 1) * sizeof(samples_t));
+
+    for(i = 0; i != trun->sample_count_; ++i)
+    {
+      samples_t* sample = &trak->samples_[s + i];
+      trun_table_t const* trun_table = &trun->table_[i];
+      unsigned int is_difference_sample = (trun_table->sample_flags_ >> 16) & 1;
+
+      cto = trun_table->sample_composition_time_offset_;
+
+      sample->pts_ = pts;
+      sample->size_ = trun_table->sample_size_;
+      sample->pos_ = data_offset;
+      sample->cto_ = trun_table->sample_composition_time_offset_;
+//      sample->is_ss_ = i == 0 ? 1 : 0;
+      sample->is_smooth_ss_ = i == 0 ? 1 : 0;
+      sample->is_ss_ = is_difference_sample ? 0 : 1;
+
+#if 0
+      {
+        unsigned int depends_on = (trun_table->sample_flags_ >> 24) & 3;
+        unsigned int is_depended_on = (trun_table->sample_flags_ >> 22) & 3;
+        unsigned int has_redundancy = (trun_table->sample_flags_ >> 20) & 3;
+        unsigned int padding_value = (trun_table->sample_flags_ >> 17) & 7;
+        unsigned int is_difference_sample = (trun_table->sample_flags_ >> 16) & 1;
+        unsigned int degradation_priority = (trun_table->sample_flags_ >> 0) & 0xffff;
+        MP4_INFO("sample_flags: depends_on=%u is_depended_on=%u has_redundancy=%u padding=%u is_difference_sample=%u degradation_priority=%u\n",
+                depends_on, is_depended_on, has_redundancy, padding_value, is_difference_sample, degradation_priority);
+      }
+#endif
+
+      pts += trun_table->sample_duration_;
+      data_offset += sample->size_;
+
+      // add fragment duration to track duration
+      trak->mdia_->mdhd_->duration_ += trun_table->sample_duration_;
+//      trak->fragment_pts_ += trun_table->sample_duration_;
+    }
+
+    // write end pts
+    trak->samples_[s + i].pts_ = pts;
+    trak->samples_[s + i].size_ = 0;
+    trak->samples_[s + i].pos_ = data_offset;
+    trak->samples_[s + i].cto_ = cto;
+    trak->samples_[s + i].is_ss_ = 1;
+    trak->samples_[s + i].is_smooth_ss_ = 1;
+  }
+
+  return 1;
+}
+
+static void* trun_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* parent,
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  trun_t* atom = trun_init();
+  traf_t* traf = (traf_t*)parent;
+  tfhd_t* tfhd = traf->tfhd_;
+
+  if(size < 8)
+    return 0;
+
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->sample_count_ = read_32(buffer + 4);
+  buffer += 8;
+
+  if(atom->flags_ & 0x0001)
+  {
+    atom->data_offset_ = read_32(buffer);
+    buffer += 4;
+  }
+  if(atom->flags_ & 0x0004)
+  {
+    atom->first_sample_flags_ = read_32(buffer);
+    buffer += 4;
+  }
+
+  atom->table_ = (trun_table_t*)malloc(atom->sample_count_ * sizeof(trun_table_t));
+  for(i = 0; i != atom->sample_count_; ++i)
+  {
+    uint32_t sample_duration = tfhd->default_sample_duration_;
+    uint32_t sample_size = tfhd->default_sample_size_;
+    uint32_t sample_flags = tfhd->default_sample_flags_;
+    uint32_t sample_composition_time_offset = 0;
+
+    if(atom->flags_ & 0x0100)
+    {
+      sample_duration = read_32(buffer);
+      buffer += 4;
+    }
+
+    if(atom->flags_ & 0x0200)
+    {
+      sample_size = read_32(buffer);
+      buffer += 4;
+    }
+
+    if(atom->flags_ & 0x0400)
+    {
+      sample_flags = read_32(buffer);
+      buffer += 4;
+    }
+    else
+    if(i == 0 && (atom->flags_ & 0x0004))
+    {
+      sample_flags = atom->first_sample_flags_;
+    }
+
+    if(atom->flags_ & 0x0800)
+    {
+      sample_composition_time_offset = read_32(buffer);
+      buffer += 4;
+    }
+
+    atom->table_[i].sample_duration_ = sample_duration;
+    atom->table_[i].sample_size_ = sample_size;
+    atom->table_[i].sample_flags_ = sample_flags;
+    atom->table_[i].sample_composition_time_offset_ =
+      sample_composition_time_offset;
+  }
+
+  return atom;
+}
+
+static void* tfhd_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  unsigned int i;
+
+  tfhd_t* atom = tfhd_init();
+
+  moov_t const* moov = mp4_context->moov;
+  mvex_t const* mvex = moov->mvex_;
+  trex_t* trex = NULL;
+
+  if(size < 8)
+    return 0;
+
+  if(mvex == NULL)
+  {
+    MP4_ERROR("%s", "tfhd: mvex not found\n");
+    return 0;
+  }
+
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->track_id_ = read_32(buffer + 4);
+  buffer += 8;
+
+//  trex_t trex_default;
+//  trex_default.default_sample_description_index_ = 1;
+//  trex_default.default_sample_duration_ = 0;
+//  trex_default.default_sample_size_ = 0;
+//  trex_default.default_sample_flags_ = 0;
+
+//  if(mvex == NULL)
+//  {
+//    trex = &trex_default;
+  //}
+//  else
+//  {
+    for(i = 0; i != mvex->tracks_; ++i)
+    {
+      if(mvex->trexs_[i]->track_id_ == atom->track_id_)
+      {
+        trex = mvex->trexs_[i];
+        break;
+      }
+    }
+//  }
+
+  if(trex == NULL)
+  {
+    MP4_ERROR("tfhd: trex not found (track_id=%u)\n", atom->track_id_);
+    return 0;
+  }
+
+  if(atom->flags_ & 0x000001)
+  {
+    atom->base_data_offset_ = read_64(buffer);
+    buffer += 8;
+  }
+  else
+  {
+    atom->base_data_offset_ = mp4_context->moof_offset_;
+  }
+  if(atom->flags_ & 0x000002)
+  {
+    atom->sample_description_index_ = read_32(buffer);
+    buffer += 4;
+  }
+  else
+  {
+    atom->sample_description_index_ = trex->default_sample_description_index_;
+  }
+  if(atom->flags_ & 0x000008)
+  {
+    atom->default_sample_duration_ = read_32(buffer);
+    buffer += 4;
+  }
+  else
+  {
+    atom->default_sample_duration_ = trex->default_sample_duration_;
+  }
+  if(atom->flags_ & 0x000010)
+  {
+    atom->default_sample_size_ = read_32(buffer);
+    buffer += 4;
+  }
+  else
+  {
+    atom->default_sample_size_ = trex->default_sample_size_;
+  }
+  if(atom->flags_ & 0x000020)
+  {
+    atom->default_sample_flags_ = read_32(buffer);
+    buffer += 4;
+  }
+  else
+  {
+    atom->default_sample_flags_ = trex->default_sample_flags_;
+  }
+
+  return atom;
+}
+
+static int traf_add_tfhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* tfhd)
+{
+  traf_t* traf = (traf_t*)parent;
+  traf->tfhd_ = (tfhd_t*)tfhd;
+
+  return 1;
+}
+
+static int traf_add_trun(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  traf_t* traf = (traf_t*)parent;
+  trun_t* trun = (trun_t*)child;
+
+  trun_t** adder = &traf->trun_;
+  while(*adder != NULL)
+  {
+    adder = &(*adder)->next_;
+  }
+  *adder = trun;
+
+  return 1;
+}
+
+static void* traf_read(mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  traf_t* atom = traf_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('t', 'f', 'h', 'd'), &traf_add_tfhd, &tfhd_read },
+    { FOURCC('t', 'r', 'u', 'n'), &traf_add_trun, &trun_read }
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->tfhd_)
+  {
+    MP4_ERROR("%s", "traf: missing tfhd\n");
+    traf_exit(atom);
+    return 0;
+  }
+
+  if(!result)
+  {
+    traf_exit(atom);
+    return 0;
+  }
+
+  if(!add_fragmented_samples(mp4_context, atom))
+  {
+    traf_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static void* mfhd_read(mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  mfhd_t* atom = mfhd_init();
+
+  if(size < 8)
+    return 0;
+
+  atom->version_ = read_8(buffer + 0);
+  atom->flags_ = read_24(buffer + 1);
+
+  atom->sequence_number_ = read_32(buffer + 4);
+
+  return atom;
+}
+
+static int moof_add_mfhd(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* mfhd)
+{
+  moof_t* moof = (moof_t*)parent;
+  moof->mfhd_ = (mfhd_t*)mfhd;
+
+  return 1;
+}
+
+static int moof_add_traf(mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  moof_t* moof = (moof_t*)parent;
+  traf_t* traf = (traf_t*)child;
+  if(moof->tracks_ == MAX_TRACKS)
+  {
+    traf_exit(traf);
+    return 0;
+  }
+
+  moof->trafs_[moof->tracks_] = traf;
+  ++moof->tracks_;
+
+  return 1;
+}
+
+extern void* moof_read(struct mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  moof_t* atom = moof_init();
+
+  atom_read_list_t atom_read_list[] = {
+    { FOURCC('m', 'f', 'h', 'd'), &moof_add_mfhd, &mfhd_read },
+    { FOURCC('t', 'r', 'a', 'f'), &moof_add_traf, &traf_read },
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  // check for mandatory atoms
+  if(!atom->mfhd_)
+  {
+    MP4_ERROR("%s", "moof: missing mfhd\n");
+    result = 0;
+  }
+
+  if(!atom->tracks_)
+  {
+    MP4_ERROR("%s", "moof: missing traf\n");
+    result = 0;
+  }
+
+  if(!result)
+  {
+    moof_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+static int trak_build_index(mp4_context_t const* mp4_context, trak_t* trak)
+{
+  stco_t const* stco = trak->mdia_->minf_->stbl_->stco_;
+  int have_samples = 1;
+  unsigned int stco_samples = 0;
+
+  if(stco == NULL || stco->entries_ == 0)
+  {
+    have_samples = 0;
+  }
+
+  if(have_samples)
+  {
+    trak->chunks_size_ = stco->entries_;
+    trak->chunks_ = (chunks_t*)malloc(trak->chunks_size_ * sizeof(chunks_t));
+
+    {
+      unsigned int i;
+      for(i = 0; i != trak->chunks_size_; ++i)
+      {
+        trak->chunks_[i].pos_ = stco->chunk_offsets_[i];
+      }
+    }
+  }
+
+  // process chunkmap:
+  if(have_samples)
+  {
+    stsc_t const* stsc = trak->mdia_->minf_->stbl_->stsc_;
+    unsigned int last = trak->chunks_size_;
+    unsigned int i = stsc->entries_;
+    while(i > 0)
+    {
+      unsigned int j;
+
+      --i;
+
+      for(j = stsc->table_[i].chunk_; j < last; j++)
+      {
+        trak->chunks_[j].id_ = stsc->table_[i].id_;
+        trak->chunks_[j].size_ = stsc->table_[i].samples_;
+      }
+      last = stsc->table_[i].chunk_;
+    }
+  }
+
+  // calc pts of chunks:
+  if(have_samples)
+  {
+    stsz_t const* stsz = trak->mdia_->minf_->stbl_->stsz_;
+    unsigned int sample_size = stsz->sample_size_;
+    unsigned int s = 0;
+    {
+      unsigned int j;
+      for(j = 0; j < trak->chunks_size_; j++)
+      {
+        trak->chunks_[j].sample_ = s;
+        s += trak->chunks_[j].size_;
+      }
+    }
+    stco_samples = s;
+
+    if(sample_size == 0)
+    {
+      trak->samples_size_ = stsz->entries_;
+    }
+    else
+    {
+      trak->samples_size_ = s;
+    }
+
+    // reserve one extra for the end information (like pts and cto).
+    trak->samples_ = (samples_t*)calloc(trak->samples_size_ + 1, sizeof(samples_t));
+
+    if(sample_size == 0)
+    {
+      unsigned int i;
+      for(i = 0; i != trak->samples_size_ ; ++i)
+        trak->samples_[i].size_ = stsz->sample_sizes_[i];
+    }
+    else
+    {
+      unsigned int i;
+      for(i = 0; i != trak->samples_size_ ; ++i)
+        trak->samples_[i].size_ = sample_size;
+    }
+  }
+
+  // calc pts:
+  if(have_samples)
+  {
+    stts_t const* stts = trak->mdia_->minf_->stbl_->stts_;
+    unsigned int s = 0;
+    uint64_t pts = 0;
+    unsigned int entries = stts->entries_;
+    unsigned int j;
+    for(j = 0; j < entries; j++)
+    {
+      unsigned int i;
+      unsigned int sample_count = stts->table_[j].sample_count_;
+      unsigned int sample_duration = stts->table_[j].sample_duration_;
+      for(i = 0; i < sample_count; i++)
+      {
+        trak->samples_[s].pts_ = pts;
+        ++s;
+        pts += sample_duration;
+      }
+    }
+    // write end pts
+    trak->samples_[s].pts_ = pts;
+  }
+
+  // calc composition times:
+  if(have_samples)
+  {
+    ctts_t const* ctts = trak->mdia_->minf_->stbl_->ctts_;
+    if(ctts)
+    {
+      unsigned int s = 0;
+      unsigned int entries = ctts->entries_;
+      unsigned int j;
+      unsigned int sample_offset = 0;
+
+      for(j = 0; j != entries; j++)
+      {
+        unsigned int i;
+        unsigned int sample_count = ctts->table_[j].sample_count_;
+        sample_offset = ctts->table_[j].sample_offset_;
+        for(i = 0; i < sample_count; i++)
+        {
+          if(s == trak->samples_size_)
+          {
+            MP4_WARNING("Warning: ctts_get_samples=%u, should be %u\n",
+                   ctts_get_samples(ctts), trak->samples_size_);
+            break;
+          }
+
+          trak->samples_[s].cto_ = sample_offset;
+          ++s;
+        }
+      }
+      // write end cto
+      trak->samples_[s].cto_ = sample_offset;
+    }
+  }
+
+  // calc sample offsets
+  if(have_samples)
+  {
+    unsigned int s = 0;
+    unsigned int j;
+    for(j = 0; j != trak->chunks_size_; j++)
+    {
+      uint64_t pos = trak->chunks_[j].pos_;
+      unsigned int i;
+      for(i = 0; i != trak->chunks_[j].size_; i++)
+      {
+        if(s == trak->samples_size_)
+        {
+          MP4_WARNING("Warning: stco_get_samples=%u, should be %u\n",
+                 stco_samples, trak->samples_size_);
+          break;
+        }
+        trak->samples_[s].pos_ = pos;
+        pos += trak->samples_[s].size_;
+        ++s;
+      }
+    }
+  }
+
+  if(have_samples)
+  {
+    stss_t const* stss = trak->mdia_->minf_->stbl_->stss_;
+    unsigned int i;
+    if(stss)
+    {
+      // TODO: The chunks for smooth streaming are now aligned to the keyframes.
+      // We may want to consider skipping some keyframes and use a
+      // minimal_increment_between_keyframes (say 2 seconds) as some chunks
+      // can be very small.
+      for(i = 0; i != stss->entries_; ++i)
+      {
+        uint32_t s = stss->sample_numbers_[i] - 1;
+        trak->samples_[s].is_ss_ = 1;
+        trak->samples_[s].is_smooth_ss_ = 1;
+      }
+    }
+    else
+    {
+      for(i = 0; i != trak->samples_size_; ++i)
+      {
+        trak->samples_[i].is_ss_ = 1;
+      }
+    }
+    // write end ss
+    trak->samples_[trak->samples_size_].is_ss_ = 1;
+    trak->samples_[trak->samples_size_].is_smooth_ss_ = 1;
+  }
+
+  return 1;
+}
+
+static void copy_sync_samples_to_audio_track(trak_t* video, trak_t* audio)
+{
+  if(video)
+  {
+    samples_t* first = video->samples_;
+    samples_t* last = video->samples_ + video->samples_size_;
+    samples_t* audio_first = audio->samples_;
+    samples_t* audio_last = audio->samples_ + audio->samples_size_;
+    while(first != last)
+    {
+      if(first->is_smooth_ss_)
+      {
+        uint64_t pts = trak_time_to_moov_time(first->pts_,
+          audio->mdia_->mdhd_->timescale_, video->mdia_->mdhd_->timescale_);
+        while(audio_first != audio_last)
+        {
+          if(audio_first->pts_ >= pts)
+          {
+            audio_first->is_smooth_ss_ = 1;
+            break;
+          }
+          ++audio_first;
+        }
+      }
+      ++first;
+    }
+  }
+  else
+  {
+    // if there is no video track and we don't have sync samples, then insert
+    // smooth sync samples every 2 seconds
+    samples_t* f = audio->samples_;
+    samples_t* l = audio->samples_ + audio->samples_size_;
+    uint64_t pts = 0;
+    uint64_t increment = 2 * audio->mdia_->mdhd_->timescale_;
+    while(f != l)
+    {
+      if(f->pts_ >= pts)
+      {
+        f->is_smooth_ss_ = 1;
+        pts += increment;
+      }
+      ++f;
+    }
+  }
+}
+
+extern int moov_build_index(struct mp4_context_t const* mp4_context,
+                            struct moov_t* moov)
+{
+  // Build the track index
+  trak_t* video_trak = NULL;
+  unsigned int track;
+
+  // already indexed?
+  if(moov->is_indexed_)
+  {
+    return 1;
+  }
+  moov->is_indexed_ = 1;
+
+  for(track = 0; track != moov->tracks_; ++track)
+  {
+    trak_t* trak = moov->traks_[track];
+    if(trak->mdia_->hdlr_->handler_type_ == FOURCC('v', 'i', 'd', 'e'))
+    {
+      video_trak = trak;
+    }
+    if(!trak_build_index(mp4_context, trak))
+    {
+      return 0;
+    }
+  }
+
+  if(!moov->mvex_)
+  {
+    for(track = 0; track != moov->tracks_; ++track)
+    {
+      trak_t* trak = moov->traks_[track];
+      if(trak->mdia_->hdlr_->handler_type_ == FOURCC('s', 'o', 'u', 'n'))
+      {
+        // Copy the sync sample markers for smooth streaming from the video trak
+        // to the audio trak in case the audio track doesn't have an 'stss'.
+        if(!trak->mdia_->minf_->stbl_->stss_)
+        {
+          copy_sync_samples_to_audio_track(video_trak, trak);
+        }
+      }
+    }
+  }
+
+  return 1;
+}
+
+static void* tfra_read(struct mp4_context_t const* UNUSED(mp4_context),
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t UNUSED(size))
+{
+  unsigned int i;
+  unsigned int length_fields;
+
+  tfra_t* tfra = tfra_init();
+
+  tfra->version_ = read_8(buffer + 0);
+  tfra->flags_ = read_24(buffer + 1);
+
+  tfra->track_id_ = read_32(buffer + 4);
+  length_fields = read_32(buffer + 8);
+  tfra->length_size_of_traf_num_ = (((length_fields >> 4) & 3) + 1);
+  tfra->length_size_of_trun_num_ = (((length_fields >> 2) & 3) + 1);
+  tfra->length_size_of_sample_num_ = (((length_fields >> 0) & 3) + 1);
+  tfra->number_of_entry_ = read_32(buffer + 12);
+  tfra->table_ = (tfra_table_t*)malloc(tfra->number_of_entry_ * sizeof(tfra_table_t));
+  buffer += 16;
+  for(i = 0; i != tfra->number_of_entry_; ++i)
+  {
+    if(tfra->version_ == 0)
+    {
+      tfra->table_[i].time_ = read_32(buffer + 0);
+      tfra->table_[i].moof_offset_ = read_32(buffer + 4);
+      buffer += 8;
+    }
+    else
+    {
+      tfra->table_[i].time_ = read_64(buffer + 0);
+      tfra->table_[i].moof_offset_ = read_64(buffer + 8);
+      buffer += 16;
+    }
+    tfra->table_[i].traf_number_ =
+      read_n(buffer, tfra->length_size_of_traf_num_ * 8) - 1;
+    buffer += tfra->length_size_of_traf_num_;
+
+    tfra->table_[i].trun_number_ =
+      read_n(buffer, tfra->length_size_of_trun_num_ * 8) - 1;
+    buffer += tfra->length_size_of_trun_num_;
+
+    tfra->table_[i].sample_number_ =
+      read_n(buffer, tfra->length_size_of_sample_num_ * 8) - 1;
+    buffer += tfra->length_size_of_sample_num_ ;
+  }
+
+  return tfra;
+}
+
+static int mfra_add_tfra(struct mp4_context_t const* UNUSED(mp4_context),
+                         void* parent, void* child)
+{
+  mfra_t* mfra = (mfra_t*)parent;
+  tfra_t* tfra = (tfra_t*)child;
+  if(mfra->tracks_ == MAX_TRACKS)
+  {
+    mfra_exit(mfra);
+    return 0;
+  }
+
+  mfra->tfras_[mfra->tracks_] = tfra;
+  ++mfra->tracks_;
+
+  return 1;
+}
+
+extern void* mfra_read(struct mp4_context_t const* mp4_context,
+                       void* UNUSED(parent),
+                       unsigned char* buffer, uint64_t size)
+{
+  mfra_t* atom = mfra_init();
+
+  struct atom_read_list_t atom_read_list[] = {
+    { FOURCC('t', 'f', 'r', 'a'), &mfra_add_tfra, &tfra_read },
+  };
+
+  int result = atom_reader(mp4_context,
+                  atom_read_list,
+                  sizeof(atom_read_list) / sizeof(atom_read_list[0]),
+                  atom,
+                  buffer, size);
+
+  if(!result)
+  {
+    mfra_exit(atom);
+    return 0;
+  }
+
+  return atom;
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_reader.h ./src/mp4_reader.h
--- ../lighttpd-1.4.26.orig/src/mp4_reader.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_reader.h	2010-06-03 15:36:00.878379056 +0200
@@ -0,0 +1,70 @@
+/*******************************************************************************
+ mp4_reader.h - A library for reading MPEG4.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef MP4_READER_H_AKW
+#define MP4_READER_H_AKW
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mp4_context_t;
+struct moov_t;
+
+struct atom_read_list_t
+{
+  uint32_t type_;
+  int (*destination_)(struct mp4_context_t const* mp4_context,
+                      void* parent, void* child);
+  void* (*reader_)(struct mp4_context_t const* mp4_context,
+                   void* parent, unsigned char* buffer, uint64_t size);
+};
+typedef struct atom_read_list_t atom_read_list_t;
+MOD_STREAMING_DLL_LOCAL extern
+int atom_reader(struct mp4_context_t const* mp4_context,
+                struct atom_read_list_t* atom_read_list,
+                unsigned int atom_read_list_size,
+                void* parent,
+                unsigned char* buffer, uint64_t size);
+
+MOD_STREAMING_DLL_LOCAL extern
+void* moov_read(struct mp4_context_t const* mp4_context,
+                void* parent,
+                unsigned char* buffer, uint64_t size);
+
+MOD_STREAMING_DLL_LOCAL extern
+void* moof_read(struct mp4_context_t const* mp4_context,
+                void* parent,
+                unsigned char* buffer, uint64_t size);
+
+MOD_STREAMING_DLL_LOCAL extern
+int moov_build_index(struct mp4_context_t const* mp4_context,
+                     struct moov_t* moov);
+
+MOD_STREAMING_DLL_LOCAL extern
+void* mfra_read(struct mp4_context_t const* mp4_context,
+                void* parent,
+                unsigned char* buffer, uint64_t size);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // MP4_READER_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_writer.c ./src/mp4_writer.c
--- ../lighttpd-1.4.26.orig/src/mp4_writer.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_writer.c	2010-06-03 15:36:00.881390874 +0200
@@ -0,0 +1,1082 @@
+/*******************************************************************************
+ mp4_writer.c - A library for writing MPEG4.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef __cplusplus
+#define __STDC_FORMAT_MACROS // C++ should define this for PRIu64
+#define __STDC_LIMIT_MACROS  // C++ should define this for UINT64_MAX
+#endif
+
+#include "mp4_writer.h"
+#include "mp4_io.h"
+#include <stdlib.h>
+#include <string.h>
+
+static unsigned char* atom_writer_unknown(unknown_atom_t* atoms,
+                                          unsigned char* buffer)
+{
+  while(atoms)
+  {
+    size_t size = read_32((const unsigned char*)atoms->atom_);
+    memcpy(buffer, atoms->atom_, size);
+    buffer += size;
+    atoms = atoms->next_;
+  }
+
+  return buffer;
+}
+
+extern unsigned char* atom_writer(struct unknown_atom_t* unknown_atoms,
+                                  atom_write_list_t* atom_write_list,
+                                  unsigned int atom_write_list_size,
+                                  unsigned char* buffer)
+{
+  unsigned i;
+  const int write_box64 = 0;
+
+  for(i = 0; i != atom_write_list_size; ++i)
+  {
+    if(atom_write_list[i].source_ != 0)
+    {
+      unsigned char* atom_start = buffer;
+      // atom size
+      if(write_box64)
+      {
+        write_32(buffer, 1); // box64
+      }
+      buffer += 4;
+
+      // atom type
+      buffer = write_32(buffer, atom_write_list[i].type_);
+      if(write_box64)
+      {
+        buffer += 8; // box64
+      }
+
+      // atom payload
+      buffer = atom_write_list[i].writer_(atom_write_list[i].source_, buffer);
+
+      if(write_box64)
+        write_64(atom_start + 8, buffer - atom_start);
+      else
+        write_32(atom_start, (uint32_t)(buffer - atom_start));
+    }
+  }
+
+  if(unknown_atoms)
+  {
+    buffer = atom_writer_unknown(unknown_atoms, buffer);
+  }
+
+  return buffer;
+}
+
+static unsigned char* tkhd_write(void const* atom, unsigned char* buffer)
+{
+  tkhd_t const* tkhd = (tkhd_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, tkhd->version_);
+  buffer = write_24(buffer, tkhd->flags_);
+
+  if(tkhd->version_ == 0)
+  {
+    buffer = write_32(buffer, (uint32_t)tkhd->creation_time_);
+    buffer = write_32(buffer, (uint32_t)tkhd->modification_time_);
+    buffer = write_32(buffer, tkhd->track_id_);
+    buffer = write_32(buffer, tkhd->reserved_);
+    buffer = write_32(buffer, (uint32_t)tkhd->duration_);
+  }
+  else
+  {
+    buffer = write_64(buffer, tkhd->creation_time_);
+    buffer = write_64(buffer, tkhd->modification_time_);
+    buffer = write_32(buffer, tkhd->track_id_);
+    buffer = write_32(buffer, tkhd->reserved_);
+    buffer = write_64(buffer, tkhd->duration_);
+  }
+
+  buffer = write_32(buffer, tkhd->reserved2_[0]);
+  buffer = write_32(buffer, tkhd->reserved2_[1]);
+  buffer = write_16(buffer, tkhd->layer_);
+  buffer = write_16(buffer, tkhd->predefined_);
+  buffer = write_16(buffer, tkhd->volume_);
+  buffer = write_16(buffer, tkhd->reserved3_);
+
+  for(i = 0; i != 9; ++i)
+  {
+    buffer = write_32(buffer, tkhd->matrix_[i]);
+  }
+
+  buffer = write_32(buffer, tkhd->width_);
+  buffer = write_32(buffer, tkhd->height_);
+
+  return buffer;
+}
+
+static unsigned char* mdhd_write(void const* atom, unsigned char* buffer)
+{
+  mdhd_t const* mdhd = (mdhd_t const*)atom;
+
+  buffer = write_8(buffer, mdhd->version_);
+  buffer = write_24(buffer, mdhd->flags_);
+
+  if(mdhd->version_ == 0)
+  {
+    buffer = write_32(buffer, (uint32_t)mdhd->creation_time_);
+    buffer = write_32(buffer, (uint32_t)mdhd->modification_time_);
+    buffer = write_32(buffer, mdhd->timescale_);
+    buffer = write_32(buffer, (uint32_t)mdhd->duration_);
+  }
+  else
+  {
+    buffer = write_64(buffer, mdhd->creation_time_);
+    buffer = write_64(buffer, mdhd->modification_time_);
+    buffer = write_32(buffer, mdhd->timescale_);
+    buffer = write_64(buffer, mdhd->duration_);
+  }
+
+  buffer = write_16(buffer,
+                    ((mdhd->language_[0] - 0x60) << 10) +
+                    ((mdhd->language_[1] - 0x60) << 5) +
+                    ((mdhd->language_[2] - 0x60) << 0));
+
+  buffer = write_16(buffer, mdhd->predefined_);
+
+  return buffer;
+}
+
+static unsigned char* vmhd_write(void const* atom, unsigned char* buffer)
+{
+  vmhd_t const* vmhd = (vmhd_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, vmhd->version_);
+  buffer = write_24(buffer, vmhd->flags_);
+  buffer = write_16(buffer, vmhd->graphics_mode_);
+  for(i = 0; i != 3; ++i)
+  {
+    buffer = write_16(buffer, vmhd->opcolor_[i]);
+  }
+
+  return buffer;
+}
+
+static unsigned char* smhd_write(void const* atom, unsigned char* buffer)
+{
+  smhd_t const* smhd = (smhd_t const*)atom;
+
+  buffer = write_8(buffer, smhd->version_);
+  buffer = write_24(buffer, smhd->flags_);
+
+  buffer = write_16(buffer, smhd->balance_);
+  buffer = write_16(buffer, smhd->reserved_);
+
+  return buffer;
+}
+
+static unsigned char* dref_write(void const* atom, unsigned char* buffer)
+{
+  unsigned int i;
+  dref_t const* dref = (dref_t const*)atom;
+
+  buffer = write_8(buffer, dref->version_);
+  buffer = write_24(buffer, dref->flags_);
+  buffer = write_32(buffer, dref->entry_count_);
+
+  for(i = 0; i != dref->entry_count_; ++i)
+  {
+    dref_table_t* entry = &dref->table_[i];
+    if(entry->flags_ == 0x000001)
+    {
+      write_32(buffer + 0, 12);
+      write_32(buffer + 4, FOURCC('u', 'r', 'l', ' '));
+      write_32(buffer + 8, entry->flags_);
+      buffer += 12;
+    }
+    else
+    {
+    // TODO: implement urn and url
+    }
+  }
+
+  return buffer;
+}
+
+static unsigned char* dinf_write(void const* atom, unsigned char* buffer)
+{
+  dinf_t const* dinf = (dinf_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('d', 'r', 'e', 'f'), dinf->dref_, &dref_write },
+  };
+
+  buffer = atom_writer(NULL,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+static unsigned char* hdlr_write(void const* atom, unsigned char* buffer)
+{
+  hdlr_t const* hdlr = (hdlr_t const*)atom;
+  buffer = write_8(buffer, hdlr->version_);
+  buffer = write_24(buffer, hdlr->flags_);
+
+  buffer = write_32(buffer, hdlr->predefined_);
+  buffer = write_32(buffer, hdlr->handler_type_);
+  buffer = write_32(buffer, hdlr->reserved1_);
+  buffer = write_32(buffer, hdlr->reserved2_);
+  buffer = write_32(buffer, hdlr->reserved3_);
+  if(hdlr->name_)
+  {
+    char const* p;
+    if(hdlr->predefined_ == FOURCC('m', 'h', 'l', 'r'))
+    {
+      buffer = write_8(buffer, (unsigned int)(strlen(hdlr->name_)));
+    }
+
+    for(p = hdlr->name_; *p; ++p)
+    {
+      buffer = write_8(buffer, *p);
+    }
+
+    if(hdlr->predefined_ != FOURCC('m', 'h', 'l', 'r'))
+    {
+      buffer = write_8(buffer, '\0');
+    }
+  }
+
+  return buffer;
+}
+
+static unsigned char*
+video_sample_entry_write(video_sample_entry_t const* sample_entry,
+                         unsigned char* buffer)
+{
+  buffer = write_16(buffer, sample_entry->version_);
+  buffer = write_16(buffer, sample_entry->revision_level_);
+  buffer = write_32(buffer, sample_entry->vendor_);
+  buffer = write_32(buffer, sample_entry->temporal_quality_);
+  buffer = write_32(buffer, sample_entry->spatial_quality_);
+  buffer = write_16(buffer, sample_entry->width_);
+  buffer = write_16(buffer, sample_entry->height_);
+  buffer = write_32(buffer, sample_entry->horiz_resolution_);
+  buffer = write_32(buffer, sample_entry->vert_resolution_);
+  buffer = write_32(buffer, sample_entry->data_size_);
+  buffer = write_16(buffer, sample_entry->frame_count_);
+  memcpy(buffer, sample_entry->compressor_name_, 32);
+  buffer += 32;
+  buffer = write_16(buffer, sample_entry->depth_);
+  buffer = write_16(buffer, sample_entry->color_table_id_);
+
+  return buffer;
+}
+
+static unsigned char*
+audio_sample_entry_write(audio_sample_entry_t const* sample_entry,
+                         unsigned char* buffer)
+{
+  buffer = write_16(buffer, sample_entry->version_);
+  buffer = write_16(buffer, sample_entry->revision_);
+  buffer = write_32(buffer, sample_entry->vendor_);
+  buffer = write_16(buffer, sample_entry->channel_count_);
+  buffer = write_16(buffer, sample_entry->sample_size_);
+  buffer = write_16(buffer, sample_entry->compression_id_);
+  buffer = write_16(buffer, sample_entry->packet_size_);
+  buffer = write_32(buffer, sample_entry->samplerate_);
+
+  return buffer;
+}
+
+static unsigned char* avcc_write(void const* atom, unsigned char* buffer)
+{
+  sample_entry_t const* sample_entry = (sample_entry_t const*)atom;
+
+  memcpy(buffer, sample_entry->codec_private_data_,
+         sample_entry->codec_private_data_length_);
+  buffer += sample_entry->codec_private_data_length_;
+
+  return buffer;
+}
+
+// returns the size of the descriptor including the tag and length
+static unsigned int mp4_desc_len(uint32_t v)
+{
+  unsigned int bytes = 0;
+
+  if(v >= 0x00200000)
+    ++bytes;
+  if(v >= 0x00004000)
+    ++bytes;
+  if(v >= 0x00000080)
+    ++bytes;
+  ++bytes;
+
+  return 1 + bytes + v;
+}
+
+static unsigned char* mp4_write_desc_len(unsigned char* buffer, uint32_t v)
+{
+  if(v >= 0x00200000)
+    buffer = write_8(buffer, (v >> 21) | 0x80);
+  if(v >= 0x00004000)
+    buffer = write_8(buffer, (v >> 14) | 0x80);
+  if(v >= 0x00000080)
+    buffer = write_8(buffer, (v >>  7) | 0x80);
+
+  buffer = write_8(buffer, v & 0x7f);
+
+  return buffer;
+}
+
+// http://www.geocities.com/xhelmboyx/quicktime/formats/mp4-layout.txt
+static unsigned char* esds_write(void const* atom, unsigned char* buffer)
+{
+  sample_entry_t const* sample_entry = (sample_entry_t const*)atom;
+
+  uint32_t decoder_specific_descriptor_length =
+    sample_entry->codec_private_data_length_ ?
+      mp4_desc_len(sample_entry->codec_private_data_length_) : 0;
+  uint32_t decoder_config_descriptor_length =
+    13 + decoder_specific_descriptor_length;
+  uint32_t elementary_stream_descriptor_length =
+    3 + mp4_desc_len(decoder_config_descriptor_length);
+
+  buffer = write_8(buffer, 0);              // version
+  buffer = write_24(buffer, 0);             // flags
+
+  buffer = write_8(buffer, MP4_ELEMENTARY_STREAM_DESCRIPTOR_TAG);
+  buffer = mp4_write_desc_len(buffer, elementary_stream_descriptor_length);
+  buffer = write_16(buffer, 1);             // track_id
+  buffer = write_8(buffer, 0);              // flags
+
+  buffer = write_8(buffer, MP4_DECODER_CONFIG_DESCRIPTOR_TAG);
+  buffer = mp4_write_desc_len(buffer, decoder_config_descriptor_length);
+
+  buffer = write_8(buffer, MP4_MPEG4Audio); // object_type_id
+  buffer = write_8(buffer, 0x15);           // stream_type (0x11=vid, 0x15=aud)
+  buffer = write_24(buffer, 0);             // buffer_size_db
+  buffer = write_32(buffer, 0);             // max_bitrate
+  buffer = write_32(buffer, 0);             // avg_bitrate
+
+  if(sample_entry->codec_private_data_length_)
+  {
+    buffer = write_8(buffer, MP4_DECODER_SPECIFIC_DESCRIPTOR_TAG);
+    buffer = mp4_write_desc_len(buffer,
+      sample_entry->codec_private_data_length_);
+    memcpy(buffer, sample_entry->codec_private_data_, 
+      sample_entry->codec_private_data_length_);
+    buffer += sample_entry->codec_private_data_length_;
+  }
+
+  buffer = write_8(buffer, 6);              // SL
+  buffer = mp4_write_desc_len(buffer, 1);
+  buffer = write_8(buffer, 0x02);
+
+  return buffer;
+}
+
+static unsigned char* stsd_write(void const* atom, unsigned char* buffer)
+{
+  stsd_t const* stsd = (stsd_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, stsd->version_);
+  buffer = write_24(buffer, stsd->flags_);
+  buffer = write_32(buffer, stsd->entries_);
+  for(i = 0; i != stsd->entries_; ++i)
+  {
+    sample_entry_t const* sample_entry = &stsd->sample_entries_[i];
+    unsigned int j = 0;
+    if(sample_entry->buf_ != NULL)
+    {
+      // just copy the sample_entry as we read it
+      buffer = write_32(buffer, sample_entry->len_ + 8);
+      buffer = write_32(buffer, sample_entry->fourcc_);
+      for(j = 0; j != sample_entry->len_; ++j)
+      {
+        buffer = write_8(buffer, sample_entry->buf_[j]);
+      }
+    }
+    else
+    {
+      unsigned char* sample_entry_buffer = buffer;
+      buffer = write_32(buffer, 0);
+      buffer = write_32(buffer, sample_entry->fourcc_);
+
+      buffer = write_32(buffer, 0); // 6 bytes reserved
+      buffer = write_16(buffer, 0);
+      buffer = write_16(buffer, 1); // data reference index
+
+      if(sample_entry->video_)
+      {
+        atom_write_list_t atom_write_list[] = {
+          { FOURCC('a', 'v', 'c', 'C'), sample_entry, &avcc_write },
+        };
+
+        buffer = video_sample_entry_write(sample_entry->video_, buffer);
+
+        buffer = atom_writer(NULL,
+                             atom_write_list,
+                             sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                             buffer);
+      }
+      else if(sample_entry->audio_)
+      {
+        atom_write_list_t atom_write_list[] = {
+          { FOURCC('e', 's', 'd', 's'), sample_entry, &esds_write },
+        };
+
+        buffer = audio_sample_entry_write(sample_entry->audio_, buffer);
+
+        buffer = atom_writer(NULL,
+                             atom_write_list,
+                             sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                             buffer);
+      }
+      write_32(sample_entry_buffer, buffer - sample_entry_buffer);
+    }
+  }
+
+  return buffer;
+}
+
+static unsigned char* stts_write(void const* atom, unsigned char* buffer)
+{
+  stts_t const* stts = (stts_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, stts->version_);
+  buffer = write_24(buffer, stts->flags_);
+  buffer = write_32(buffer, stts->entries_);
+  for(i = 0; i != stts->entries_; ++i)
+  {
+    buffer = write_32(buffer, stts->table_[i].sample_count_);
+    buffer = write_32(buffer, stts->table_[i].sample_duration_);
+  }
+
+  return buffer;
+}
+
+static unsigned char* stss_write(void const* atom, unsigned char* buffer)
+{
+  stss_t const* stss = (stss_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, stss->version_);
+  buffer = write_24(buffer, stss->flags_);
+  buffer = write_32(buffer, stss->entries_);
+  for(i = 0; i != stss->entries_; ++i)
+  {
+    buffer = write_32(buffer, stss->sample_numbers_[i]);
+  }
+
+  return buffer;
+}
+
+static unsigned char* stsc_write(void const* atom, unsigned char* buffer)
+{
+  stsc_t const* stsc = (stsc_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, stsc->version_);
+  buffer = write_24(buffer, stsc->flags_);
+  buffer = write_32(buffer, stsc->entries_);
+  for(i = 0; i != stsc->entries_; ++i)
+  {
+    buffer = write_32(buffer, stsc->table_[i].chunk_ + 1);
+    buffer = write_32(buffer, stsc->table_[i].samples_);
+    buffer = write_32(buffer, stsc->table_[i].id_);
+  }
+
+  return buffer;
+}
+
+static unsigned char* stsz_write(void const* atom, unsigned char* buffer)
+{
+  stsz_t const* stsz = (stsz_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, stsz->version_);
+  buffer = write_24(buffer, stsz->flags_);
+  buffer = write_32(buffer, stsz->sample_size_);
+  buffer = write_32(buffer, stsz->entries_);
+  if(!stsz->sample_size_)
+  {
+    for(i = 0; i != stsz->entries_; ++i)
+    {
+      buffer = write_32(buffer, stsz->sample_sizes_[i]);
+    }
+  }
+
+  return buffer;
+}
+
+static unsigned char* stco_write(void const* atom, unsigned char* buffer)
+{
+  stco_t const* stco = (stco_t const*)atom;
+  unsigned int i;
+
+  // newly generated stco (patched inplace)
+  ((stco_t*)stco)->stco_inplace_ = buffer;
+
+  buffer = write_8(buffer, stco->version_);
+  buffer = write_24(buffer, stco->flags_);
+  buffer = write_32(buffer, stco->entries_);
+  for(i = 0; i != stco->entries_; ++i)
+  {
+    buffer = write_32(buffer, (uint32_t)(stco->chunk_offsets_[i]));
+  }
+
+  return buffer;
+}
+
+static unsigned char* ctts_write(void const* atom, unsigned char* buffer)
+{
+  ctts_t const* ctts = (ctts_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, ctts->version_);
+  buffer = write_24(buffer, ctts->flags_);
+  buffer = write_32(buffer, ctts->entries_);
+  for(i = 0; i != ctts->entries_; ++i)
+  {
+    buffer = write_32(buffer, (uint32_t)(ctts->table_[i].sample_count_));
+    buffer = write_32(buffer, (uint32_t)(ctts->table_[i].sample_offset_));
+  }
+
+  return buffer;
+}
+
+static unsigned char* stbl_write(void const* atom, unsigned char* buffer)
+{
+  stbl_t const* stbl = (stbl_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('s', 't', 's', 'd'), stbl->stsd_, &stsd_write },
+    { FOURCC('s', 't', 't', 's'), stbl->stts_, &stts_write },
+    { FOURCC('c', 't', 't', 's'), stbl->ctts_, &ctts_write },
+    { FOURCC('s', 't', 's', 'c'), stbl->stsc_, &stsc_write },
+    { FOURCC('s', 't', 's', 'z'), stbl->stsz_, &stsz_write },
+    { FOURCC('s', 't', 'c', 'o'), stbl->stco_, &stco_write },
+    { FOURCC('s', 't', 's', 's'), stbl->stss_, &stss_write },
+  };
+
+  buffer = atom_writer(stbl->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+static unsigned char* minf_write(void const* atom, unsigned char* buffer)
+{
+  minf_t const* minf = (minf_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('v', 'm', 'h', 'd'), minf->vmhd_, &vmhd_write },
+    { FOURCC('s', 'm', 'h', 'd'), minf->smhd_, &smhd_write },
+    { FOURCC('d', 'i', 'n', 'f'), minf->dinf_, &dinf_write },
+    { FOURCC('s', 't', 'b', 'l'), minf->stbl_, &stbl_write }
+  };
+
+  buffer = atom_writer(minf->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+static unsigned char* mdia_write(void const* atom, unsigned char* buffer)
+{
+  mdia_t const* mdia = (mdia_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('m', 'd', 'h', 'd'), mdia->mdhd_, &mdhd_write },
+    { FOURCC('h', 'd', 'l', 'r'), mdia->hdlr_, &hdlr_write },
+    { FOURCC('m', 'i', 'n', 'f'), mdia->minf_, &minf_write }
+  };
+
+  buffer = atom_writer(mdia->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+static unsigned char* elst_write(void const* atom, unsigned char* buffer)
+{
+  elst_t const* elst = (elst_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, elst->version_);
+  buffer = write_24(buffer, elst->flags_);
+  buffer = write_32(buffer, elst->entry_count_);
+  for(i = 0; i != elst->entry_count_; ++i)
+  {
+    if(elst->version_ == 0)
+    {
+      buffer = write_32(buffer, (uint32_t)(elst->table_[i].segment_duration_));
+      buffer = write_32(buffer, (uint32_t)(elst->table_[i].media_time_));
+    }
+    else
+    {
+      buffer = write_64(buffer, elst->table_[i].segment_duration_);
+      buffer = write_64(buffer, elst->table_[i].media_time_);
+    }
+    buffer = write_16(buffer, elst->table_[i].media_rate_integer_);
+    buffer = write_16(buffer, elst->table_[i].media_rate_fraction_);
+  }
+
+  return buffer;
+}
+
+static unsigned char* edts_write(void const* atom, unsigned char* buffer)
+{
+  edts_t const* edts = (edts_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('e', 'l', 's', 't'), edts->elst_, &elst_write }
+  };
+
+  buffer = atom_writer(edts->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+static unsigned char* trak_write(void const* atom, unsigned char* buffer)
+{
+  trak_t const* trak = (trak_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('t', 'k', 'h', 'd'), trak->tkhd_, &tkhd_write },
+    { FOURCC('m', 'd', 'i', 'a'), trak->mdia_, &mdia_write },
+    { FOURCC('e', 'd', 't', 's'), trak->edts_, &edts_write }
+  };
+
+  buffer = atom_writer(trak->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+static unsigned char* mvhd_write(void const* atom, unsigned char* buffer)
+{
+  mvhd_t const* mvhd = (mvhd_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, mvhd->version_);
+  buffer = write_24(buffer, mvhd->flags_);
+
+  if(mvhd->version_ == 0)
+  {
+    buffer = write_32(buffer, (uint32_t)mvhd->creation_time_);
+    buffer = write_32(buffer, (uint32_t)mvhd->modification_time_);
+    buffer = write_32(buffer, mvhd->timescale_);
+    buffer = write_32(buffer, (uint32_t)mvhd->duration_);
+  }
+  else
+  {
+    buffer = write_64(buffer, mvhd->creation_time_);
+    buffer = write_64(buffer, mvhd->modification_time_);
+    buffer = write_32(buffer, mvhd->timescale_);
+    buffer = write_64(buffer, mvhd->duration_);
+  }
+
+  buffer = write_32(buffer, mvhd->rate_);
+  buffer = write_16(buffer, mvhd->volume_);
+  buffer = write_16(buffer, mvhd->reserved1_);
+  buffer = write_32(buffer, mvhd->reserved2_[0]);
+  buffer = write_32(buffer, mvhd->reserved2_[1]);
+
+  for(i = 0; i != 9; ++i)
+  {
+    buffer = write_32(buffer, mvhd->matrix_[i]);
+  }
+
+  for(i = 0; i != 6; ++i)
+  {
+    buffer = write_32(buffer, mvhd->predefined_[i]);
+  }
+
+  buffer = write_32(buffer, mvhd->next_track_id_);
+
+  return buffer;
+}
+
+static unsigned char* trex_write(void const* atom, unsigned char* buffer)
+{
+  trex_t const* trex = (trex_t const*)atom;
+
+  buffer = write_8(buffer, trex->version_);
+  buffer = write_24(buffer, trex->flags_);
+
+  buffer = write_32(buffer, trex->track_id_);
+  buffer = write_32(buffer, trex->default_sample_description_index_);
+  buffer = write_32(buffer, trex->default_sample_duration_);
+  buffer = write_32(buffer, trex->default_sample_size_);
+  buffer = write_32(buffer, trex->default_sample_flags_);
+
+  return buffer;
+}
+
+static unsigned char* mvex_write(void const* atom, unsigned char* buffer)
+{
+  mvex_t const* mvex = (mvex_t const*)atom;
+
+  unsigned i;
+
+  buffer = atom_writer(mvex->unknown_atoms_, NULL, 0, buffer);
+
+  for(i = 0; i != mvex->tracks_; ++i)
+  {
+    atom_write_list_t mvex_atom_write_list[] = {
+//    { FOURCC('m', 'e', 'h', 'd'), NULL, NULL },
+      { FOURCC('t', 'r', 'e', 'x'), mvex->trexs_[i], &trex_write },
+    };
+    buffer = atom_writer(0,
+                         mvex_atom_write_list,
+                         sizeof(mvex_atom_write_list) / sizeof(mvex_atom_write_list[0]),
+                         buffer);
+  }
+
+  return buffer;
+}
+
+extern uint32_t moov_write(moov_t* atom, unsigned char* buffer)
+{
+  unsigned i;
+
+  unsigned char* atom_start = buffer;
+
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('m', 'v', 'h', 'd'), atom->mvhd_, &mvhd_write },
+    { FOURCC('m', 'v', 'e', 'x'), atom->mvex_, &mvex_write }
+  };
+
+  // atom size
+  buffer += 4;
+
+  // atom type
+  buffer = write_32(buffer, FOURCC('m', 'o', 'o', 'v'));
+
+  buffer = atom_writer(atom->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  for(i = 0; i != atom->tracks_; ++i)
+  {
+    atom_write_list_t trak_atom_write_list[] = {
+      { FOURCC('t', 'r', 'a', 'k'), atom->traks_[i], &trak_write },
+    };
+    buffer = atom_writer(0,
+                         trak_atom_write_list,
+                         sizeof(trak_atom_write_list) / sizeof(trak_atom_write_list[0]),
+                         buffer);
+  }
+
+  write_32(atom_start, (uint32_t)(buffer - atom_start));
+
+  return buffer - atom_start;
+}
+
+static unsigned char* tfra_write(void const* atom, unsigned char* buffer)
+{
+  tfra_t const* tfra = (tfra_t const*)atom;
+  unsigned int i;
+  uint32_t length_fields;
+
+  buffer = write_8(buffer, tfra->version_);
+  buffer = write_24(buffer, tfra->flags_);
+
+  buffer = write_32(buffer, tfra->track_id_);
+  length_fields = ((tfra->length_size_of_traf_num_ - 1) << 4) +
+                  ((tfra->length_size_of_trun_num_ - 1) << 2) +
+                  ((tfra->length_size_of_sample_num_ - 1) << 0);
+  buffer = write_32(buffer, length_fields);
+
+  buffer = write_32(buffer, tfra->number_of_entry_);
+  for(i = 0; i != tfra->number_of_entry_; ++i)
+  {
+    tfra_table_t* table = &tfra->table_[i];
+    if(tfra->version_ == 0)
+    {
+      buffer = write_32(buffer, (uint32_t)table->time_);
+      buffer = write_32(buffer, (uint32_t)table->moof_offset_);
+    }
+    else
+    {
+      buffer = write_64(buffer, table->time_);
+      buffer = write_64(buffer, table->moof_offset_);
+    }
+
+    buffer = write_n(buffer, tfra->length_size_of_traf_num_ * 8, 
+                     table->traf_number_ + 1);
+    buffer = write_n(buffer, tfra->length_size_of_trun_num_ * 8, 
+                     table->trun_number_ + 1);
+    buffer = write_n(buffer, tfra->length_size_of_sample_num_ * 8, 
+                     table->sample_number_ + 1);
+  }
+
+  return buffer;
+}
+
+extern uint32_t mfra_write(mfra_t const* mfra, unsigned char* buffer)
+{
+  unsigned i;
+
+  unsigned char* atom_start = buffer;
+  uint32_t atom_size;
+
+  // atom size
+  buffer += 4;
+
+  // atom type
+  buffer = write_32(buffer, FOURCC('m', 'f', 'r', 'a'));
+
+  buffer = atom_writer(mfra->unknown_atoms_, NULL, 0, buffer);
+
+  for(i = 0; i != mfra->tracks_; ++i)
+  {
+    atom_write_list_t mfra_atom_write_list[] = {
+      { FOURCC('t', 'f', 'r', 'a'), mfra->tfras_[i], &tfra_write },
+    };
+    buffer = atom_writer(0,
+                         mfra_atom_write_list,
+                         sizeof(mfra_atom_write_list) / sizeof(mfra_atom_write_list[0]),
+                         buffer);
+  }
+
+  // write Movie Fragment Random Access Offset Box (mfro)
+  {
+    buffer = write_32(buffer, 16);
+    buffer = write_32(buffer, FOURCC('m', 'f', 'r', 'o'));
+    buffer = write_32(buffer, 0);
+    buffer = write_32(buffer, (uint32_t)(buffer - atom_start + 4));
+  }
+
+  atom_size = (uint32_t)(buffer - atom_start);
+  write_32(atom_start, atom_size);
+
+  return atom_size;
+}
+
+static unsigned char* tfhd_write(void const* atom, unsigned char* buffer)
+{
+  struct tfhd_t const* tfhd = (struct tfhd_t const*)atom;
+
+  buffer = write_8(buffer, tfhd->version_);
+  buffer = write_24(buffer, tfhd->flags_);
+
+  buffer = write_32(buffer, tfhd->track_id_);
+
+  if(tfhd->flags_ & 0x000001)
+  {
+    buffer = write_64(buffer, tfhd->base_data_offset_);
+  }
+  if(tfhd->flags_ & 0x000002)
+  {
+    buffer = write_32(buffer, tfhd->sample_description_index_);
+  }
+  if(tfhd->flags_ & 0x000008)
+  {
+    buffer = write_32(buffer, tfhd->default_sample_duration_);
+  }
+  if(tfhd->flags_ & 0x000010)
+  {
+    buffer = write_32(buffer, tfhd->default_sample_size_);
+  }
+  if(tfhd->flags_ & 0x000020)
+  {
+    buffer = write_32(buffer, tfhd->default_sample_flags_);
+  }
+
+  return buffer;
+}
+
+static unsigned char* trun_write(void const* atom, unsigned char* buffer)
+{
+  // TODO: add writing of multiple truns (we can't do that here, as we need to
+  // write an atom header for each trun)
+  trun_t const* trun = (trun_t const*)atom;
+  unsigned int i;
+
+  buffer = write_8(buffer, trun->version_);
+  buffer = write_24(buffer, trun->flags_);
+
+  buffer = write_32(buffer, trun->sample_count_);
+
+  // data offset
+  if(trun->flags_ & 0x0001)
+  {
+    buffer = write_32(buffer, trun->data_offset_);
+  }
+  // first sample flag
+  if(trun->flags_ & 0x0004)
+  {
+    buffer = write_32(buffer, trun->first_sample_flags_);
+  }
+
+  for(i = 0; i != trun->sample_count_; ++i)
+  {
+    if(trun->flags_ & 0x0100)
+    {
+      buffer = write_32(buffer, trun->table_[i].sample_duration_);
+    }
+    if(trun->flags_ & 0x0200)
+    {
+      buffer = write_32(buffer, trun->table_[i].sample_size_);
+    }
+    if(trun->flags_ & 0x0800)
+    {
+      buffer = write_32(buffer, trun->table_[i].sample_composition_time_offset_);
+    }
+  }
+
+  return buffer;
+}
+
+static unsigned char* uuid0_write(void const* atom, unsigned char* buffer)
+{
+  uuid0_t const* uuid = (uuid0_t const*)atom;
+
+  static const unsigned char uuid0[] = {
+    0x6d, 0x1d, 0x9b, 0x05, 0x42, 0xd5, 0x44, 0xe6,
+    0x80, 0xe2, 0x14, 0x1d, 0xaf, 0xf7, 0x57, 0xb2
+  };
+
+  memcpy(buffer, uuid0, sizeof(uuid0));
+  buffer += sizeof(uuid0);
+
+  buffer = write_8(buffer, 0x01);
+  buffer = write_24(buffer, 0x00);
+  buffer = write_64(buffer, uuid->pts_);
+  buffer = write_64(buffer, uuid->duration_);
+
+  return buffer;
+}
+
+static unsigned char* uuid1_write(void const* atom, unsigned char* buffer)
+{
+  uuid1_t const* uuid = (uuid1_t const*)atom;
+
+  static const unsigned char uuid1[] = {
+    0xd4, 0x80, 0x7e, 0xf2, 0xca, 0x39, 0x46, 0x95,
+    0x8e, 0x54, 0x26, 0xcb, 0x9e, 0x46, 0xa7, 0x9f
+  };
+  unsigned int i;
+
+  memcpy(buffer, uuid1, sizeof(uuid1));
+  buffer += sizeof(uuid1);
+
+  buffer = write_8(buffer, 0x01);
+  buffer = write_24(buffer, 0x00);
+
+  buffer = write_8(buffer, uuid->entries_);
+  for(i = 0; i != uuid->entries_; ++i)
+  {
+    buffer = write_64(buffer, uuid->pts_[i]);
+    buffer = write_64(buffer, uuid->duration_[i]);
+  }
+
+#if 0
+  // 0x485482a4d55 = 497048.7893333 = 138:04:08.7893333
+  // 0x485498ebf55 = 497051.1253333 = 138:04:11.1253333
+  // 0x1647200 = 2.3360000
+  // 0x1339e00 = 2.0160000
+
+  buffer = write_64(buffer, 0x00000485482a4d55);
+  buffer = write_64(buffer, 0x1647200); // next duration?
+
+  buffer = write_64(buffer, 0x00000485498ebf55);
+  buffer = write_64(buffer, 0x1339e00); // next next duration?
+#endif
+
+  return buffer;
+}
+
+static unsigned char* mfhd_write(void const* atom, unsigned char* buffer)
+{
+  mfhd_t const* mfhd = (mfhd_t const*)atom;
+
+  buffer = write_8(buffer, mfhd->version_);
+  buffer = write_24(buffer, mfhd->flags_);
+
+  buffer = write_32(buffer, mfhd->sequence_number_);
+
+  return buffer;
+}
+
+static unsigned char* traf_write(void const* atom, unsigned char* buffer)
+{
+  traf_t const* traf = (traf_t const*)atom;
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('t', 'f', 'h', 'd'), traf->tfhd_, &tfhd_write },
+    { FOURCC('t', 'r', 'u', 'n'), traf->trun_, &trun_write },
+#if 1 // defined(HACK_LIVE_SMOOTH_STREAMING)
+    { FOURCC('u', 'u', 'i', 'd'), traf->uuid0_, &uuid0_write },
+    { FOURCC('u', 'u', 'i', 'd'), traf->uuid1_, &uuid1_write }
+#endif
+  };
+
+  buffer = atom_writer(traf->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  return buffer;
+}
+
+extern uint32_t moof_write(struct moof_t* atom, unsigned char* buffer)
+{
+  unsigned i;
+
+  unsigned char* atom_start = buffer;
+
+  atom_write_list_t atom_write_list[] = {
+    { FOURCC('m', 'f', 'h', 'd'), atom->mfhd_, &mfhd_write },
+  };
+
+  // atom size
+  buffer += 4;
+
+  // atom type
+  buffer = write_32(buffer, FOURCC('m', 'o', 'o', 'f'));
+
+  buffer = atom_writer(atom->unknown_atoms_,
+                       atom_write_list,
+                       sizeof(atom_write_list) / sizeof(atom_write_list[0]),
+                       buffer);
+
+  for(i = 0; i != atom->tracks_; ++i)
+  {
+    atom_write_list_t traf_atom_write_list[] = {
+      { FOURCC('t', 'r', 'a', 'f'), atom->trafs_[i], &traf_write },
+    };
+    buffer = atom_writer(0,
+                         traf_atom_write_list,
+                         sizeof(traf_atom_write_list) / sizeof(traf_atom_write_list[0]),
+                         buffer);
+  }
+  write_32(atom_start, (uint32_t)(buffer - atom_start));
+
+  return buffer - atom_start;
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/mp4_writer.h ./src/mp4_writer.h
--- ../lighttpd-1.4.26.orig/src/mp4_writer.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/mp4_writer.h	2010-06-03 15:36:00.882394906 +0200
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ mp4_writer.h - A library for writing MPEG4.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef MP4_WRITER_H_AKW
+#define MP4_WRITER_H_AKW
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct unknown_atom_t;
+struct moov_t;
+struct mfra_t;
+struct moof_t;
+
+struct atom_write_list_t
+{
+  uint32_t type_;
+  void const* source_;
+  unsigned char* (*writer_)(void const* atom, unsigned char* buffer);
+};
+typedef struct atom_write_list_t atom_write_list_t;
+MOD_STREAMING_DLL_LOCAL extern
+unsigned char* atom_writer(struct unknown_atom_t* unknown_atoms,
+                           atom_write_list_t* atom_write_list,
+                           unsigned int atom_write_list_size,
+                           unsigned char* buffer);
+
+MOD_STREAMING_DLL_LOCAL extern
+uint32_t moov_write(struct moov_t* atom, unsigned char* buffer);
+
+MOD_STREAMING_DLL_LOCAL extern
+uint32_t mfra_write(struct mfra_t const* mfra, unsigned char* buffer);
+
+MOD_STREAMING_DLL_LOCAL extern
+uint32_t moof_write(struct moof_t* atom, unsigned char* buffer);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // MP4_WRITER_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/output_bucket.c ./src/output_bucket.c
--- ../lighttpd-1.4.26.orig/src/output_bucket.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/output_bucket.c	2010-06-03 15:36:00.882394906 +0200
@@ -0,0 +1,108 @@
+/*******************************************************************************
+ output_bucket.c - A library for writing memory / file buckets.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define _CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+#endif
+
+#include "output_bucket.h"
+#include <stdlib.h>
+#include <string.h>
+
+extern bucket_t* bucket_init(enum bucket_type_t bucket_type)
+{
+  bucket_t* bucket = (bucket_t*)malloc(sizeof(bucket_t));
+  bucket->type_ = bucket_type;
+  bucket->prev_ = bucket;
+  bucket->next_ = bucket;
+
+  return bucket;
+}
+
+extern void bucket_exit(bucket_t* bucket)
+{
+  switch(bucket->type_)
+  {
+  case BUCKET_TYPE_MEMORY:
+    free(bucket->buf_);
+    break;
+  case BUCKET_TYPE_FILE:
+    break;
+  }
+  free(bucket);
+}
+
+extern bucket_t* bucket_init_memory(void const* buf, uint64_t size)
+{
+  bucket_t* bucket = bucket_init(BUCKET_TYPE_MEMORY);
+  bucket->buf_ = malloc((size_t)size);
+  memcpy(bucket->buf_, buf, (size_t)size);
+  bucket->size_ = size;
+  return bucket;
+}
+
+extern bucket_t* bucket_init_file(uint64_t offset, uint64_t size)
+{
+  bucket_t* bucket = bucket_init(BUCKET_TYPE_FILE);
+  bucket->offset_ = offset;
+  bucket->size_ = size;
+  return bucket;
+}
+
+static void bucket_insert_after(bucket_t* after, bucket_t* bucket)
+{
+  bucket->prev_ = after;
+  bucket->next_ = after->next_;
+  after->next_->prev_ = bucket;
+  after->next_ = bucket;
+}
+
+extern void bucket_insert_tail(bucket_t** head, bucket_t* bucket)
+{
+  if(*head == NULL)
+  {
+    *head = bucket;
+  }
+
+  bucket_insert_after((*head)->prev_, bucket);
+}
+
+extern void bucket_insert_head(bucket_t** head, bucket_t* bucket)
+{
+  bucket_insert_tail(head, bucket);
+  *head = bucket;
+}
+
+extern void bucket_remove(bucket_t* bucket)
+{
+  bucket_t* prev = bucket->prev_;
+  bucket_t* next = bucket->next_;
+  bucket->prev_->next_ = next;
+  bucket->next_->prev_ = prev;
+}
+
+extern void buckets_exit(bucket_t* buckets)
+{
+  bucket_t* bucket = buckets;
+  do
+  {
+    bucket_t* next = bucket->next_;
+    bucket_exit(bucket);
+    bucket = next;
+  } while(bucket != buckets);
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/output_bucket.h ./src/output_bucket.h
--- ../lighttpd-1.4.26.orig/src/output_bucket.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/output_bucket.h	2010-06-03 15:36:00.883399217 +0200
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ output_bucket.h - A library for writing memory / file buckets.
+
+ Copyright (C) 2007-2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef OUTPUT_BUCKET_H_AKW
+#define OUTPUT_BUCKET_H_AKW
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum bucket_type_t
+{
+  BUCKET_TYPE_MEMORY,
+  BUCKET_TYPE_FILE,
+};
+typedef enum bucket_type_t bucket_type_t;
+
+struct bucket_t
+{
+  int type_;
+//  union {
+    void* buf_;
+    uint64_t offset_;
+//  };
+  uint64_t size_;
+  struct bucket_t* prev_;
+  struct bucket_t* next_;
+};
+typedef struct bucket_t bucket_t;
+MOD_STREAMING_DLL_LOCAL extern bucket_t* bucket_init(bucket_type_t bucket_type);
+MOD_STREAMING_DLL_LOCAL extern void bucket_exit(bucket_t* bucket);
+MOD_STREAMING_DLL_LOCAL extern
+bucket_t* bucket_init_memory(void const* buf, uint64_t size);
+MOD_STREAMING_DLL_LOCAL extern
+bucket_t* bucket_init_file(uint64_t offset, uint64_t size);
+MOD_STREAMING_DLL_LOCAL extern
+void buckets_exit(bucket_t* buckets);
+MOD_STREAMING_DLL_LOCAL extern
+void bucket_insert_tail(bucket_t** head, bucket_t* bucket);
+MOD_STREAMING_DLL_LOCAL extern
+void bucket_insert_head(bucket_t** head, bucket_t* bucket);
+MOD_STREAMING_DLL_LOCAL extern
+void bucket_remove(bucket_t* bucket);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // OUTPUT_BUCKET_H_AKW
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/output_mp4.c ./src/output_mp4.c
--- ../lighttpd-1.4.26.orig/src/output_mp4.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/output_mp4.c	2010-06-03 15:36:00.885407003 +0200
@@ -0,0 +1,620 @@
+/*******************************************************************************
+ output_mp4.c - A library for writing MPEG4.
+
+ Copyright (C) 2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef __cplusplus
+#define __STDC_FORMAT_MACROS // C++ should define this for PRIu64
+#define __STDC_LIMIT_MACROS  // C++ should define this for UINT64_MAX
+#endif
+
+#include "output_mp4.h"
+#include "mp4_io.h"
+#include "mp4_writer.h"
+#include "moov.h"
+#include "output_bucket.h"
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>  // FreeBSD doesn't define off_t in stdio.h
+
+#if defined HAVE_ZLIB_H && defined HAVE_LIBZ
+// Compress the MOOV atom. Turn this off for Flash as it doesn't support it.
+// # define COMPRESS_MOOV_ATOM
+# include <zlib.h>
+#endif
+
+// traffic shaping: create offsets for each second
+static void create_traffic_shaping(moov_t* moov,
+                                   unsigned int const* trak_sample_start,
+                                   unsigned int const* trak_sample_end,
+                                   int64_t offset,
+                                   mp4_split_options_t* options)
+{
+  uint64_t moov_duration = moov->mvhd_->duration_;
+  long moov_time_scale = moov->mvhd_->timescale_;
+
+  unsigned int track_index;
+  int second;
+  options->seconds =
+    1 + (int)((moov_duration + moov_time_scale - 1) / moov_time_scale);
+  options->byte_offsets = (uint64_t*)
+    calloc(options->seconds, sizeof(options->byte_offsets[0]));
+  for(track_index = 0; track_index != moov->tracks_; ++track_index)
+  {
+    struct trak_t* trak = moov->traks_[track_index];
+
+    long trak_time_scale = trak->mdia_->mdhd_->timescale_;
+    struct samples_t* samples = trak->samples_;
+
+    unsigned int sample = trak_sample_start[track_index];
+    unsigned int end_sample = trak_sample_end[track_index];
+    uint64_t pts = samples[sample].pts_;
+
+    second = 0;
+
+    while(sample != end_sample)
+    {
+      uint64_t trak_end_offset = 0;
+      while(sample != end_sample && samples[sample].pts_ <= pts)
+      {
+        trak_end_offset = samples[sample].pos_;
+        trak_end_offset += samples[sample].size_;
+        trak_end_offset += offset;
+        ++sample;
+      }
+
+#if 0
+      if(second < 20)
+      {
+        MP4_INFO("moov[%d]: offset=%"PRIu64"\n", second, trak_end_offset);
+      }
+#endif
+
+      if(options->byte_offsets[second] < trak_end_offset)
+        options->byte_offsets[second] = trak_end_offset;
+
+      pts += trak_time_scale; // next second
+      ++second;
+    }
+  }
+}
+
+static void stco_shift_offsets_inplace(unsigned char* stco, int offset)
+{
+  unsigned int entries = read_32(stco + 4);
+  unsigned int* table = (unsigned int*)(stco + 8);
+  unsigned int i;
+  for(i = 0; i != entries; ++i)
+    write_32((unsigned char*)&table[i], (read_32((unsigned char*)&table[i]) + offset));
+}
+
+static void trak_shift_offsets_inplace(struct trak_t* trak, int64_t offset)
+{
+//  void* stco = trak->mdia_->minf_->stbl_->stco_inplace_;
+  void* stco = trak->mdia_->minf_->stbl_->stco_->stco_inplace_;
+  stco_shift_offsets_inplace((unsigned char*)stco, (int32_t)offset);
+}
+
+static void moov_shift_offsets_inplace(struct moov_t* moov, int64_t offset)
+{
+  unsigned int i;
+  for(i = 0; i != moov->tracks_; ++i)
+  {
+    trak_shift_offsets_inplace(moov->traks_[i], offset);
+  }
+}
+
+
+#ifdef COMPRESS_MOOV_ATOM
+static void compress_moov(struct mp4_context_t* mp4_context,
+                          struct moov_t* moov,
+                          unsigned char* moov_data,
+                          uint64_t* moov_size)
+{
+  uLong sourceLen = (uLong)(*moov_size - ATOM_PREAMBLE_SIZE);
+  uLong destLen = compressBound(sourceLen);
+  unsigned char* cmov = (unsigned char*)malloc(destLen);
+  int zstatus = compress(cmov, &destLen, moov_data, sourceLen);
+  if(zstatus == Z_OK)
+  {
+    MP4_INFO("cmov size = %lu (%ld%%)\n", destLen, 100 * destLen / sourceLen);
+  }
+
+  {
+    const int extra_space = 4096;
+    if(destLen + extra_space < sourceLen)
+    {
+      const int bytes_saved = sourceLen - destLen;
+      uLong destLen2;
+      int extra = 0;
+      MP4_INFO("shifting offsets by %d\n", -bytes_saved);
+      moov_shift_offsets_inplace(moov, -bytes_saved);
+
+      extra += ATOM_PREAMBLE_SIZE + 4;            // dcom
+      extra += ATOM_PREAMBLE_SIZE + 4;            // cmvd
+      extra += ATOM_PREAMBLE_SIZE;                // cmov
+      extra += ATOM_PREAMBLE_SIZE + extra_space;  // free
+
+      MP4_INFO("shifting offsets by %d\n", extra);
+      moov_shift_offsets_inplace(moov, extra);
+
+      // recompress
+      destLen2 = compressBound(sourceLen);
+      zstatus = compress(cmov, &destLen2, moov_data, sourceLen);
+      if(zstatus == Z_OK)
+      {
+        MP4_INFO("cmov size = %lu (%ld%%)\n", destLen2, 100 * destLen2 / sourceLen);
+
+        if(destLen2 < destLen + extra_space)
+        {
+          // copy compressed movie atom
+          unsigned char* outbuffer = moov_data;
+
+          uint32_t dcom_size = ATOM_PREAMBLE_SIZE + 4;
+          uint32_t cmvd_size = ATOM_PREAMBLE_SIZE + 4 + destLen2;
+          uint32_t cmov_size = ATOM_PREAMBLE_SIZE + dcom_size + cmvd_size;
+          uint32_t free_size = ATOM_PREAMBLE_SIZE + extra_space + destLen - destLen2;
+          *moov_size = ATOM_PREAMBLE_SIZE + cmov_size + free_size;
+
+          outbuffer = write_32(outbuffer, (uint32_t)*moov_size);
+
+          // skip 'moov'
+          outbuffer += 4;
+
+          outbuffer = write_32(outbuffer, cmov_size);
+          {
+            outbuffer = write_32(outbuffer, FOURCC('c', 'm', 'o', 'v'));
+            outbuffer = write_32(outbuffer, dcom_size);
+            outbuffer = write_32(outbuffer, FOURCC('d', 'c', 'o', 'm'));
+            outbuffer = write_32(outbuffer, FOURCC('z', 'l', 'i', 'b'));
+
+            outbuffer = write_32(outbuffer, cmvd_size);
+            {
+              outbuffer = write_32(outbuffer, FOURCC('c', 'm', 'v', 'd'));
+              outbuffer = write_32(outbuffer, sourceLen);
+              memcpy(outbuffer, cmov, destLen2);
+              outbuffer += destLen2;
+            }
+          }
+
+          // add final padding
+          outbuffer = write_32(outbuffer, free_size);
+          outbuffer = write_32(outbuffer, FOURCC('f', 'r', 'e', 'e'));
+          {
+            const char free_bytes[8] =
+            {
+              'C', 'o', 'd', 'e','S','h', 'o', 'p'
+            };
+            uint32_t padding_index;
+            for(padding_index = ATOM_PREAMBLE_SIZE; padding_index != free_size; ++padding_index)
+            {
+              outbuffer[padding_index] = free_bytes[padding_index % 8];
+            }
+          }
+        }
+        else
+        {
+          MP4_ERROR("%s", "2nd pass compress overflow\n");
+        }
+      }
+    }
+  }
+  free(cmov);
+}
+#endif
+
+static void trak_update_index(struct mp4_context_t const* mp4_context,
+                              struct trak_t* trak,
+                              unsigned int start, unsigned int end)
+{
+  // write samples [start,end>
+
+  // stts = [entries * [sample_count, sample_duration]
+  {
+    struct stts_t* stts = trak->mdia_->minf_->stbl_->stts_;
+
+    unsigned int entries = 0;
+    unsigned int s = start;
+
+    while(s != end)
+    {
+      unsigned int sample_count = 1;
+      unsigned int sample_duration =
+        (unsigned int)(trak->samples_[s + 1].pts_ - trak->samples_[s].pts_);
+      while(++s != end)
+      {
+        if((trak->samples_[s + 1].pts_ - trak->samples_[s].pts_) != sample_duration)
+          break;
+        ++sample_count;
+      }
+// TODO: entries may be empty when we read a fragmented movie file. use
+// output_mov() instead.
+//      if(entries + 1 > stts->entries_)
+//      {
+//        stts->table_ = (stts_table_t*)
+//          realloc(stts->table_, (entries + 1) * sizeof(stts_table_t));
+//      }
+
+      stts->table_[entries].sample_count_ = sample_count;
+      stts->table_[entries].sample_duration_ = sample_duration;
+      ++entries;
+    }
+    stts->entries_ = entries;
+
+    if(stts_get_samples(stts) != end - start)
+    {
+      MP4_WARNING("ERROR: stts_get_samples=%d, should be %d\n",
+             stts_get_samples(stts), end - start);
+    }
+  }
+
+  // ctts = [entries * [sample_count, sample_offset]
+  {
+    struct ctts_t* ctts = trak->mdia_->minf_->stbl_->ctts_;
+    if(ctts)
+    {
+      unsigned int entries = 0;
+      unsigned int s = start;
+
+      while(s != end)
+      {
+        unsigned int sample_count = 1;
+        unsigned int sample_offset = trak->samples_[s].cto_;
+        while(++s != end)
+        {
+          if(trak->samples_[s].cto_ != sample_offset)
+            break;
+          ++sample_count;
+        }
+        // write entry
+        ctts->table_[entries].sample_count_ = sample_count;
+        ctts->table_[entries].sample_offset_ = sample_offset;
+        ++entries;
+      }
+      ctts->entries_ = entries;
+      if(ctts_get_samples(ctts) != end - start)
+      {
+        MP4_WARNING("ERROR: ctts_get_samples=%d, should be %d\n",
+               ctts_get_samples(ctts), end - start);
+      }
+    }
+  }
+
+  // process chunkmap:
+  {
+    struct stsc_t* stsc = trak->mdia_->minf_->stbl_->stsc_;
+    if(stsc != NULL)
+    {
+      unsigned int i;
+
+      for(i = 0; i != trak->chunks_size_; ++i)
+      {
+        if(trak->chunks_[i].sample_ + trak->chunks_[i].size_ > start)
+          break;
+      }
+
+      {
+        unsigned int stsc_entries = 0;
+        unsigned int chunk_start = i;
+        unsigned int chunk_end;
+        // problem.mp4: reported by Jin-seok Lee. Second track contains no samples
+        if(trak->chunks_size_ != 0)
+        {
+          unsigned int samples =
+            trak->chunks_[i].sample_ + trak->chunks_[i].size_ - start;
+          unsigned int id = trak->chunks_[i].id_;
+
+          // write entry [chunk,samples,id]
+          stsc->table_[stsc_entries].chunk_ = 0;
+          stsc->table_[stsc_entries].samples_ = samples;
+          stsc->table_[stsc_entries].id_ = id;
+          ++stsc_entries;
+
+          if(i != trak->chunks_size_)
+          {
+            for(i += 1; i != trak->chunks_size_; ++i)
+            {
+              unsigned int next_size = trak->chunks_[i].size_;
+              if(trak->chunks_[i].sample_ + trak->chunks_[i].size_ > end)
+              {
+                next_size = end - trak->chunks_[i].sample_;
+              }
+
+              if(next_size != samples)
+              {
+                samples = next_size;
+                id = trak->chunks_[i].id_;
+                stsc->table_[stsc_entries].chunk_ = i - chunk_start;
+                stsc->table_[stsc_entries].samples_ = samples;
+                stsc->table_[stsc_entries].id_ = id;
+                ++stsc_entries;
+              }
+
+              if(trak->chunks_[i].sample_ + next_size == end)
+              {
+                break;
+              }
+            }
+          }
+        }
+        chunk_end = i + 1;
+        stsc->entries_ = stsc_entries;
+
+        {
+          struct stco_t* stco = trak->mdia_->minf_->stbl_->stco_;
+          unsigned int entries = 0;
+          for(i = chunk_start; i != chunk_end; ++i)
+          {
+            stco->chunk_offsets_[entries] = stco->chunk_offsets_[i];
+            ++entries;
+          }
+          stco->entries_ = entries;
+
+          // patch first chunk with correct sample offset
+          stco->chunk_offsets_[0] = (uint32_t)trak->samples_[start].pos_;
+        }
+      }
+    }
+  }
+
+  // process sync samples:
+  if(trak->mdia_->minf_->stbl_->stss_)
+  {
+    struct stss_t* stss = trak->mdia_->minf_->stbl_->stss_;
+    unsigned int entries = 0;
+    unsigned int stss_start;
+    unsigned int i;
+
+    for(i = 0; i != stss->entries_; ++i)
+    {
+      if(stss->sample_numbers_[i] >= start + 1)
+        break;
+    }
+    stss_start = i;
+    for(; i != stss->entries_; ++i)
+    {
+      unsigned int sync_sample = stss->sample_numbers_[i];
+      if(sync_sample >= end + 1)
+        break;
+      stss->sample_numbers_[entries] = sync_sample - start;
+      ++entries;
+    }
+    stss->entries_ = entries;
+  }
+
+  // process sample sizes
+  {
+    struct stsz_t* stsz = trak->mdia_->minf_->stbl_->stsz_;
+    if(stsz != NULL)
+    {
+      if(stsz->sample_size_ == 0)
+      {
+        unsigned int entries = 0;
+        unsigned int i;
+        for(i = start; i != end; ++i)
+        {
+          stsz->sample_sizes_[entries] = stsz->sample_sizes_[i];
+          ++entries;
+        }
+      }
+      stsz->entries_ = end - start;
+    }
+  }
+}
+
+
+extern int output_mp4(struct mp4_context_t* mp4_context,
+                      unsigned int const* trak_sample_start,
+                      unsigned int const* trak_sample_end,
+                      struct bucket_t** buckets,
+                      struct mp4_split_options_t* options)
+{
+  unsigned int i;
+
+  uint64_t mdat_start = mp4_context->mdat_atom.start_;
+  uint64_t mdat_size = mp4_context->mdat_atom.size_;
+  int64_t offset;
+
+  struct moov_t* moov = mp4_context->moov;
+//  unsigned char* moov_data = mp4_context->moov_data;
+  unsigned char* moov_data = (unsigned char*)
+    malloc((size_t)mp4_context->moov_atom.size_ + ATOM_PREAMBLE_SIZE + 1024);
+
+  uint64_t moov_size;
+
+  long moov_time_scale = moov->mvhd_->timescale_;
+  uint64_t skip_from_start = UINT64_MAX;
+  uint64_t end_offset = 0;
+
+  uint64_t moov_duration = 0;
+
+#if 1
+  uint64_t new_mdat_start = 0;
+  {
+    static char const free_data[] = {
+      0x0, 0x0, 0x0,  42, 'f', 'r', 'e', 'e',
+      'v', 'i', 'd', 'e', 'o', ' ', 's', 'e',
+      'r', 'v', 'e', 'd', ' ', 'b', 'y', ' ',
+      'm', 'o', 'd', '_', 'h', '2', '6', '4',
+      '_', 's', 't', 'r', 'e', 'a', 'm', 'i',
+      'n', 'g'
+    };
+    uint32_t size_of_header = (uint32_t)mp4_context->ftyp_atom.size_ +
+                              sizeof(free_data);
+    unsigned char* buffer = (unsigned char*)malloc(size_of_header);
+
+    if(mp4_context->ftyp_atom.size_)
+    {
+      fseeko(mp4_context->infile, mp4_context->ftyp_atom.start_, SEEK_SET);
+      if(fread(buffer, (off_t)mp4_context->ftyp_atom.size_, 1, mp4_context->infile) != 1)
+      {
+        MP4_ERROR("%s", "Error reading ftyp atom\n");
+        free(buffer);
+        return 0;
+      }
+    }
+
+    // copy free data
+    memcpy(buffer + mp4_context->ftyp_atom.size_, free_data,
+           sizeof(free_data));
+
+    if(options->output_format == OUTPUT_FORMAT_MP4)
+    {
+      bucket_t* bucket = bucket_init_memory(buffer, size_of_header);
+      bucket_insert_tail(buckets, bucket);
+    }
+    free(buffer);
+
+    new_mdat_start += size_of_header;
+  }
+
+//  new_mdat_start += mp4_context->moov_atom.size_;
+#endif
+
+  offset = new_mdat_start - mp4_context->mdat_atom.start_;
+  // subtract old moov size
+//  offset -= mp4_context->moov_atom.size_;
+
+  for(i = 0; i != moov->tracks_; ++i)
+  {
+    struct trak_t* trak = moov->traks_[i];
+    struct stbl_t* stbl = trak->mdia_->minf_->stbl_;
+
+    unsigned int start_sample = trak_sample_start[i];
+    unsigned int end_sample = trak_sample_end[i];
+
+    trak_update_index(mp4_context, trak, start_sample, end_sample);
+
+    if(trak->samples_size_ == 0)
+    {
+      MP4_WARNING("Trak %u contains no samples. Maybe a fragmented file?", i);
+      return 1;
+    }
+
+    {
+      uint64_t skip =
+        trak->samples_[start_sample].pos_ - trak->samples_[0].pos_;
+      if(skip < skip_from_start)
+        skip_from_start = skip;
+      MP4_INFO("Trak can skip %"PRIu64" bytes\n", skip);
+
+      if(end_sample != trak->samples_size_)
+      {
+        uint64_t end_pos = trak->samples_[end_sample].pos_;
+        if(end_pos > end_offset)
+          end_offset = end_pos;
+        MP4_INFO("New endpos=%"PRIu64"\n", end_pos);
+        MP4_INFO("Trak can skip %"PRIu64" bytes at end\n",
+               mdat_start + mdat_size - end_offset);
+      }
+    }
+
+    {
+      // fixup trak (duration)
+      uint64_t trak_duration = stts_get_duration(stbl->stts_);
+      long trak_time_scale = trak->mdia_->mdhd_->timescale_;
+      {
+        uint64_t duration = trak_time_to_moov_time(trak_duration,
+          moov_time_scale, trak_time_scale);
+        trak->mdia_->mdhd_->duration_= trak_duration;
+        trak->tkhd_->duration_ = duration;
+        MP4_INFO("trak: new_duration=%"PRIu64"\n", duration);
+
+        if(duration > moov_duration)
+          moov_duration = duration;
+      }
+    }
+
+//      MP4_INFO("stco.size=%d, ", read_int32(stbl->stco_ + 4));
+//      MP4_INFO("stts.size=%d samples=%d\n", read_int32(stbl->stts_ + 4), stts_get_samples(stbl->stts_));
+//      MP4_INFO("stsz.size=%d\n", read_int32(stbl->stsz_ + 8));
+//      MP4_INFO("stsc.samples=%d\n", stsc_get_samples(stbl->stsc_));
+  }
+  moov->mvhd_->duration_ = moov_duration;
+  MP4_INFO("moov: new_duration=%.2f seconds\n", moov_duration / (float)moov_time_scale);
+
+  // subtract bytes we skip at the front of the mdat atom
+  offset -= skip_from_start;
+
+  MP4_INFO("%s", "moov: writing header\n");
+
+  moov_write(moov, moov_data);
+  moov_size = read_32(moov_data);
+
+  // add new moov size
+  offset += moov_size;
+
+  MP4_INFO("shifting offsets by %"PRId64"\n", offset);
+  moov_shift_offsets_inplace(moov, offset);
+
+  // traffic shaping: create offsets for each second
+  create_traffic_shaping(moov,
+                         trak_sample_start,
+                         trak_sample_end,
+                         offset,
+                         options);
+
+#ifdef COMPRESS_MOOV_ATOM
+  if(!options->client_is_flash)
+  {
+    compress_moov(mp4_context, moov, moov_data, &moov_size);
+  }
+#endif
+
+  if(end_offset != 0)
+  {
+    MP4_INFO("mdat_size=%"PRId64" end_offset=%"PRId64"\n",
+             mdat_size, end_offset);
+    mdat_size = end_offset - mdat_start;
+  }
+  mdat_start += skip_from_start;
+  mdat_size -= skip_from_start;
+
+  MP4_INFO("mdat_bucket(%"PRId64", %"PRId64")\n", mdat_start, mdat_size);
+
+  bucket_insert_tail(buckets, bucket_init_memory(moov_data, moov_size));
+  free(moov_data);
+
+  {
+    struct mp4_atom_t mdat_atom;
+    mdat_atom.type_ = FOURCC('m', 'd', 'a', 't');
+    mdat_atom.short_size_ = 0; // TODO: use original small/wide mdat box
+
+    if(options->adaptive)
+    {
+      // empty mdat atom
+      mdat_atom.size_ = ATOM_PREAMBLE_SIZE;
+    }
+    else
+    {
+      mdat_atom.size_ = mdat_size;
+    }
+
+    {
+      unsigned char buffer[32];
+      int mdat_header_size = mp4_atom_write_header(buffer, &mdat_atom);
+      bucket_insert_tail(buckets,
+        bucket_init_memory(buffer, mdat_header_size));
+
+      if(mdat_atom.size_ - mdat_header_size)
+      {
+        bucket_insert_tail(buckets,
+          bucket_init_file(mdat_start + mdat_header_size,
+                           mdat_atom.size_ - mdat_header_size));
+      }
+    }
+  }
+
+  return 1;
+}
+
+// End Of File
+
diff -Naur ../lighttpd-1.4.26.orig/src/output_mp4.h ./src/output_mp4.h
--- ../lighttpd-1.4.26.orig/src/output_mp4.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/output_mp4.h	2010-06-03 15:36:00.885407003 +0200
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ output_mp4.h - A library for writing MPEG4.
+
+ Copyright (C) 2009 CodeShop B.V.
+ http://www.code-shop.com
+
+ For licensing see the LICENSE file
+******************************************************************************/ 
+
+#ifndef OUTPUT_MP4_H_AKW
+#define OUTPUT_MP4_H_AKW
+
+#include "mod_streaming_export.h"
+
+#ifndef _MSC_VER
+#include <inttypes.h>
+#else
+#include "inttypes.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define HAVE_OUTPUT_MP4
+
+struct mp4_context_t;
+struct bucket_t;
+struct mp4_split_options_t;
+
+MOD_STREAMING_DLL_LOCAL extern
+int output_mp4(struct mp4_context_t* mp4_context,
+               unsigned int const* trak_sample_start,
+               unsigned int const* trak_sample_end,
+               struct bucket_t** buckets,
+               struct mp4_split_options_t* options);
+
+#ifdef __cplusplus
+} /* extern C definitions */
+#endif
+
+#endif // OUTPUT_MP4_H_AKW
+
+// End Of File
+
